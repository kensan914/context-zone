/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./ContextJS/src/Layers.js":
/*!*********************************!*\
  !*** ./ContextJS/src/Layers.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Config\": () => /* binding */ Config,\n/* harmony export */   \"log_layer_code\": () => /* binding */ log_layer_code,\n/* harmony export */   \"log\": () => /* binding */ log,\n/* harmony export */   \"proceedStack\": () => /* binding */ proceedStack,\n/* harmony export */   \"GlobalLayers\": () => /* binding */ GlobalLayers,\n/* harmony export */   \"AsyncLayerStack\": () => /* binding */ AsyncLayerStack,\n/* harmony export */   \"withLogLayerCode\": () => /* binding */ withLogLayerCode,\n/* harmony export */   \"getLayerDefinitionForObject\": () => /* binding */ getLayerDefinitionForObject,\n/* harmony export */   \"ensurePartialLayer\": () => /* binding */ ensurePartialLayer,\n/* harmony export */   \"layerMethod\": () => /* binding */ layerMethod,\n/* harmony export */   \"layerProperty\": () => /* binding */ layerProperty,\n/* harmony export */   \"layerPropertyWithShadow\": () => /* binding */ layerPropertyWithShadow,\n/* harmony export */   \"computeLayersFor\": () => /* binding */ computeLayersFor,\n/* harmony export */   \"composeLayers\": () => /* binding */ composeLayers,\n/* harmony export */   \"LayerStack\": () => /* binding */ LayerStack,\n/* harmony export */   \"resetLayerStack\": () => /* binding */ resetLayerStack,\n/* harmony export */   \"currentLayers\": () => /* binding */ currentLayers,\n/* harmony export */   \"invalidateLayerComposition\": () => /* binding */ invalidateLayerComposition,\n/* harmony export */   \"lookupLayeredFunctionForObject\": () => /* binding */ lookupLayeredFunctionForObject,\n/* harmony export */   \"uninstallLayersInObject\": () => /* binding */ uninstallLayersInObject,\n/* harmony export */   \"GlobalNamedLayers\": () => /* binding */ globalContextForNamedLayers,\n/* harmony export */   \"enableLayer\": () => /* binding */ enableLayer,\n/* harmony export */   \"disableLayer\": () => /* binding */ disableLayer,\n/* harmony export */   \"proceed\": () => /* binding */ proceed,\n/* harmony export */   \"Layer\": () => /* binding */ Layer,\n/* harmony export */   \"collectWithLayersIn\": () => /* binding */ collectWithLayersIn,\n/* harmony export */   \"collectWithoutLayersIn\": () => /* binding */ collectWithoutLayersIn,\n/* harmony export */   \"structuralLayers\": () => /* binding */ structuralLayers,\n/* harmony export */   \"aysncLayers\": () => /* binding */ aysncLayers,\n/* harmony export */   \"globalLayers\": () => /* binding */ globalLayers,\n/* harmony export */   \"dynamicLayers\": () => /* binding */ dynamicLayers,\n/* harmony export */   \"activeImplicitLayers\": () => /* binding */ activeImplicitLayers,\n/* harmony export */   \"activeLayers\": () => /* binding */ activeLayers,\n/* harmony export */   \"LayerableObjectTrait\": () => /* binding */ LayerableObjectTrait,\n/* harmony export */   \"LayerableObject\": () => /* binding */ LayerableObject,\n/* harmony export */   \"COPError\": () => /* binding */ COPError,\n/* harmony export */   \"PartialLayerComposition\": () => /* binding */ PartialLayerComposition\n/* harmony export */ });\n/*\r\n * Copyright (c) 2008-2016 Hasso Plattner Institute\r\n *\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a copy\r\n * of this software and associated documentation files (the \"Software\"), to deal\r\n * in the Software without restriction, including without limitation the rights\r\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n * copies of the Software, and to permit persons to whom the Software is\r\n * furnished to do so, subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n * THE SOFTWARE.\r\n */\r\n\r\n/* \r\n * Private Helpers for Development\r\n */\r\n\r\nconst Config = {};\r\nConfig.ignoreDeprecatedProceed = true;\r\n\r\nlet log_layer_code = false;\r\nfunction log(string) {\r\n  if (log_layer_code) console.log(string);\r\n}\r\n\r\n\r\n/* \r\n * Private State\r\n */\r\n\r\n// #HACK #TODO\r\nconst proceedStack = []\r\nconst GlobalLayers = []\r\nconst AsyncLayerStack = []\r\n\r\n// export const proceedStack = [];\r\n// export const GlobalLayers = [];\r\n\r\n// hack, to work around absence of identity dictionaries in JavaScript\r\n// we could perhaps limit ourselfs to layer only those objects that respond to object.id()\r\n// because working with objects is a serialization problem in itself, perhaps we should\r\n// restrict ourself in working with classes\r\n// So classes have names and names can be used as keys in dictionaries :-)\r\nlet object_id_counter = 0;\r\n\r\n/* \r\n * Private Methods\r\n */\r\n\r\n// for debugging ContextJS itself\r\nfunction withLogLayerCode(func) {\r\n  try {\r\n    var old = log_layer_code;\r\n    log_layer_code = true;\r\n    func();\r\n  } finally {\r\n    log_layer_code = old;\r\n  }\r\n}\r\n\r\nconst LayerObjectID = Symbol(\"layerObjectID\");\r\n\r\nfunction getLayerDefinitionForObject(layer, object) {\r\n  // log(\"cop getLayerDefinitionForObject(\" + layer + \", \" + object + \")\");\r\n  if (!layer || !object) {\r\n    return;\r\n  }\r\n  var result = layer[object[LayerObjectID]];\r\n  // #BUG Maximum call stack size exceeded\r\n  try {\r\n    return result ? result : getLayerDefinitionForObject(layer, object.prototype);\r\n  } catch(e) {\r\n    debugger\r\n    console.error('getLayerDefinitionForObject', e)\r\n    return;\r\n  }\r\n}\r\n\r\n/**\r\n * Stores partial definitions for a single layered object and layer.\r\n */\r\nclass PartialLayer {\r\n  constructor(layeredObject) {\r\n    this.layeredObject = layeredObject;\r\n    this.layeredProperties = {};\r\n  }\r\n\r\n  setLayeredPropertyValue(name, value) {\r\n    this.layeredProperties[name] = value;\r\n  }\r\n\r\n  defineGetter(propertyName, getter) {\r\n    return Object.defineProperty(this.layeredProperties, propertyName,\r\n                          {get: getter, configurable: true});\r\n  }\r\n\r\n  defineSetter(propertyName, setter) {\r\n    return Object.defineProperty(this.layeredProperties, propertyName,\r\n                          {set: setter, configurable: true});\r\n  }\r\n\r\n  getterMethod(propertyName) {\r\n    var desc = Object.getOwnPropertyDescriptor(this.layeredProperties, propertyName);\r\n    if (desc)\r\n      return desc.get;\r\n  }\r\n\r\n  setterMethod(propertyName) {\r\n    var desc = Object.getOwnPropertyDescriptor(this.layeredProperties, propertyName);\r\n    if (desc)\r\n      return desc.set;\r\n  }\r\n\r\n  property(propertyName) {\r\n    if (this.layeredProperties.hasOwnProperty(propertyName)) {\r\n      return this.layeredProperties[propertyName];\r\n    }\r\n  }\r\n\r\n  reinstall() {\r\n    Object.getOwnPropertyNames(this.layeredProperties).forEach(eachProperty => {\r\n      const property = Object.getOwnPropertyDescriptor(this.layeredProperties, eachProperty);\r\n      if (typeof property.get !== 'undefined' || typeof property.set !== 'undefined') {\r\n        makePropertyLayerAware(this.layeredObject, eachProperty);\r\n      } else {\r\n        makeFunctionLayerAware(this.layeredObject, eachProperty);\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nfunction ensurePartialLayer(layer, object) {\r\n  if (!layer) {\r\n    throw new Error(\"in ensurePartialLayer: layer is nil\");\r\n  }\r\n  if (!object.hasOwnProperty(LayerObjectID)) {\r\n    Object.defineProperty(object, LayerObjectID, {\r\n      value: object_id_counter++,\r\n      enumerable: false,\r\n      configurable: false,\r\n      writable: false\r\n    });\r\n  }\r\n  if (!layer[object[LayerObjectID]]) {\r\n    layer[object[LayerObjectID]] = new PartialLayer(object);\r\n  }\r\n  return layer[object[LayerObjectID]];\r\n}\r\n\r\n// TODO(mariannet) : Find out if ES6 constructor also has type\r\nfunction layerMethod(layer, object, property, func) {\r\n  ensurePartialLayer(layer, object).setLayeredPropertyValue(property, func);\r\n  func.displayName = \"layered \" + String(layer.name) + \" \"\r\n                   + (object.constructor ? (object.constructor.type + \"$\") : \"\")\r\n                   + property;\r\n  makeFunctionLayerAware(object, property, layer.isHidden);\r\n  \r\n  // Bookkeeping for layer uninstall\r\n  // typeof object.getName === 'function'\r\n  //    && (layer._layeredFunctionsList[object][property] = true);\r\n}\r\n\r\nfunction layerGetterMethod(layer, object, property, getter) {\r\n  ensurePartialLayer(layer, object).defineGetter(property, getter);\r\n}\r\n\r\nfunction layerSetterMethod(layer, object, property, setter) {\r\n  ensurePartialLayer(layer, object).defineSetter(property, setter);\r\n}\r\n\r\nfunction layerProperty(layer, object, property, defs) { // layerProperty(this, authChecker, \"check\", {check: [function]});\r\n  var defProperty = Object.getOwnPropertyDescriptor(defs, property);\r\n  var getter = defProperty && defProperty.get;\r\n  if (getter) {\r\n    layerGetterMethod(layer, object, property, getter);\r\n  }\r\n  var setter = defProperty && defProperty.set;\r\n  if (setter) {\r\n    layerSetterMethod(layer, object, property, setter);\r\n  }\r\n  if (getter || setter) {\r\n    makePropertyLayerAware(object, property);\r\n  } else {\r\n    layerMethod(layer, object, property, defs[property]);\r\n  }\r\n}\r\n\r\nfunction layerPropertyWithShadow(layer, object, property) {\r\n  // shadowing does not work with current implementation\r\n  // see the shadow tests in LayersTest\r\n  // TODO: the tests are green, what is the above comment about?\r\n  var defs = {};\r\n  // var baseValue = object[property];\r\n  const layeredPropSymbol = self.Symbol(property + ' ' +\r\n      (typeof layer.name === 'string'\r\n       ? 'for Layer ' + layer.name\r\n       : 'for anonymous Layer'));\r\n  Object.defineProperty(defs, property, {\r\n    get: function layeredGetter() {\r\n      return this[layeredPropSymbol] === undefined ?\r\n          proceed() : this[layeredPropSymbol];\r\n    },\r\n    set: function layeredSetter(v) {\r\n      this[layeredPropSymbol] = v;\r\n    },\r\n    configurable: true\r\n  });\r\n  layerProperty(layer, object, property, defs);\r\n}\r\n\r\nfunction computeLayersFor(obj) {\r\n  return obj && obj.activeLayers ?\r\n      obj.activeLayers(activeLayers) : activeLayers();\r\n}\r\n\r\nfunction composeLayers(stack) {\r\n  var result = GlobalLayers.slice(0); // copy the array, #TODO: use `Array.from`\r\n  // duplicate of dynamicLayers, #TODO: use LayerableObjectTrait.dynamicLayers\r\n  for (var i = 0; i < stack.length; i++) {\r\n    var current = stack[i];\r\n    if (current.withLayers) {\r\n      result = result.filter(l => !current.withLayers.includes(l)).concat(current.withLayers);\r\n    } else if (current.withoutLayers) {\r\n      result = result.filter(l => !current.withoutLayers.includes(l));\r\n    }\r\n  }\r\n  return result;\r\n}\r\n\r\nlet LayerStack;\r\n\r\nfunction resetLayerStack() {\r\n  LayerStack = [{\r\n    isStatic: true,\r\n    toString: function() { return \"BaseLayer\"; },\r\n    composition: null\r\n  }];\r\n  invalidateLayerComposition();\r\n}\r\n\r\n\r\nfunction currentLayers() {\r\n  return activeLayers()\r\n  // if (LayerStack.length == 0) {\r\n  //   throw new Error(\"The default layer is missing\");\r\n  // }\r\n  // // NON OPTIMIZED VERSION FOR STATE BASED LAYER ACTIVATION \r\n  // // #TODO check if this still hold for #async\r\n  // var current = LayerStack[LayerStack.length - 1];\r\n  // if (!current.composition) {\r\n  //   current.composition = composeLayers(LayerStack) ;\r\n  // }\r\n  // return current.composition.concat(getActiveImplicitLayers());\r\n}\r\n\r\n// clear cached layer compositions\r\nfunction invalidateLayerComposition() {\r\n  LayerStack.forEach(\r\n    function(ea) {\r\n      ea.composition = null;\r\n    });\r\n}\r\n\r\nfunction lookupLayeredFunctionForObject(\r\n    self, layer, function_name, methodType, n) {\r\n  if (!layer) {\r\n    return undefined; \r\n  }\r\n  let partialFunction;\r\n  const partialLayerForObject = getLayerDefinitionForObject(layer, self);\r\n  if (partialLayerForObject) {\r\n    // log(\"  found layer definitions for object\");\r\n    if (methodType == 'getter') {\r\n      partialFunction = partialLayerForObject.getterMethod(function_name);\r\n    } else if (methodType == 'setter'){\r\n      partialFunction = partialLayerForObject.setterMethod(function_name);\r\n    } else {\r\n      partialFunction = partialLayerForObject.property(function_name);\r\n    }\r\n  }\r\n  if (!partialFunction && !self.hasOwnProperty(function_name)) {\r\n    // this method was probably added by a layer\r\n    // so try to look it up in the superclass hierachy\r\n    const superclass = Object.getPrototypeOf(self);\r\n    if (superclass) {\r\n      return lookupLayeredFunctionForObject(\r\n          superclass, layer, function_name, methodType);\r\n    }\r\n  }\r\n  return partialFunction;\r\n}\r\n\r\nfunction pvtMakeFunctionOrPropertyLayerAware(obj, slotName, baseValue, type, isHidden) {\r\n  // install in obj[slotName] a cop wrapper that weaves partial methods\r\n  // into real method (baseValue)\r\n  if (baseValue.isLayerAware) {\r\n    return;\r\n  }\r\n  makeSlotLayerAwareWithNormalLookup(obj, slotName, baseValue, type, isHidden);\r\n}\r\n\r\nfunction makeSlotLayerAwareWithNormalLookup(\r\n    obj, slotName, baseValue, type, isHidden) {\r\n  var tmpObj = {}\r\n  if (baseValue && baseValue.isLayerAware) {\r\n    debugger\r\n  }\r\n  let wrapped_function = function() {\r\n    'use strict';\r\n    \r\n    var composition =\r\n        new PartialLayerComposition(this, slotName, baseValue, type);\r\n    proceedStack.push(composition);\r\n    return invokeLayeredMethodThenPopProceedStack.apply(this, arguments);\r\n  };\r\n  wrapped_function.displayName = \"wrapped_\" + slotName    \r\n  wrapped_function.isLayerAware = true;\r\n  // this is more declarative outside of COP context\r\n  wrapped_function.isContextJSWrapper = true;\r\n  if (isHidden) {\r\n    wrapped_function.toString = function () {\r\n      return this.getOriginal().toString()\r\n    };\r\n  }\r\n  // For wrapped_function.getOriginal()\r\n  wrapped_function.originalFunction = baseValue;\r\n  if (type == \"getter\") {\r\n    Object.defineProperty(obj, slotName, {get: wrapped_function});\r\n  } else if (type == \"setter\") {\r\n    Object.defineProperty(obj, slotName, {set: wrapped_function});\r\n  } else {\r\n    Object.defineProperty(obj, slotName, {\r\n      get() { return wrapped_function; },\r\n      set(newFunction) {\r\n        if (newFunction.isLayerAware) {\r\n          // when someone reasigns an already layered method.... Example Bug. Dexie modifies Promise.then\r\n          // #Paper #ContextJS \r\n        } else {\r\n          makeSlotLayerAwareWithNormalLookup(this, slotName, newFunction);\r\n        }\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nfunction invokeLayeredMethodThenPopProceedStack() {\r\n  'use strict';\r\n  try {\r\n    return proceed.apply(void 0 /* undefined */, arguments);\r\n  } finally {\r\n    proceedStack.pop()\r\n  }\r\n}\r\n\r\nfunction makeFunctionLayerAware(base_obj, function_name, isHidden) {\r\n  if (!base_obj) {\r\n    throw new Error(\"can't layer an non existent object\");\r\n  }\r\n  /* ensure base function */\r\n  var base_function = base_obj[function_name];\r\n  if (!base_function) {\r\n    // console.log(\"WARNING can't layer an non existent function\" + function_name +\r\n    // \" , so do nothing\")\r\n    // return;\r\n    base_function = () => null;\r\n  }\r\n  pvtMakeFunctionOrPropertyLayerAware(base_obj, function_name, base_function,\r\n                                            undefined, isHidden)\r\n}\r\n\r\nfunction makePropertyLayerAware(baseObj, property) {\r\n  if (!baseObj) {\r\n    throw new Error(\"can't layer a non existent object\");\r\n  }  \r\n  // ensure base getter and setter\r\n  var baseObjProperty = Object.getOwnPropertyDescriptor(baseObj, property);\r\n  var propName = \"__layered_\" + property + \"__\";\r\n  var getter = baseObjProperty && baseObjProperty.get;\r\n  if (!getter) {\r\n    // does not work when dealing with classes and instances...\r\n    baseObj[propName] = baseObj[property]; // take over old value\r\n    getter = function() { return this[propName] };\r\n    Object.defineProperty(baseObj, property, {get: getter, configurable: true});\r\n  }\r\n  var setter = baseObjProperty && baseObjProperty.set;\r\n  if (!setter) {\r\n    setter = function(value) { return this[propName] = value };\r\n    Object.defineProperty(baseObj, property, {set: setter, configurable: true});\r\n  }\r\n  pvtMakeFunctionOrPropertyLayerAware(baseObj, property, getter, 'getter');\r\n  pvtMakeFunctionOrPropertyLayerAware(baseObj, property, setter, 'setter');\r\n}\r\n\r\nfunction makeFunctionLayerUnaware(base_obj, function_name) {\r\n  if (!base_obj) {\r\n    throw new Error(\"need object to makeFunctionLayerUnaware\");\r\n  }\r\n  var prevFunction;\r\n  var currentFunction = base_obj[function_name];\r\n  if (currentFunction === undefined) {\r\n    return; // nothing to do here\r\n  }  \r\n  while (typeof currentFunction.originalFunction == 'function'\r\n      && !currentFunction.isLayerAware) {\r\n    prevFunction = currentFunction;\r\n    currentFunction = currentFunction.originalFunction\r\n  }\r\n  if (!(currentFunction.isLayerAware)) {\r\n    return; // nothing to do here\r\n  }\r\n  var originalFunction = currentFunction.originalFunction\r\n  if (!(originalFunction instanceof Function)) {\r\n    throw new Error(\"makeFunctionLayerUnaware Error: no orignal function\");\r\n  }\r\n  if (prevFunction instanceof Function) {\r\n    prevFunction.originalFunction = originalFunction\r\n  } else {\r\n    // need to use defineProperty because the setter keeps the function wrapped\r\n    Object.defineProperty(base_obj, function_name, {\r\n      value: originalFunction,\r\n      configurable: true\r\n    });\r\n  }\r\n}\r\n\r\nfunction uninstallLayersInObject(object) {\r\n  Object.getOwnPropertyNames(object).forEach(ea => {\r\n    if (typeof object[ea] === 'function')\r\n      makeFunctionLayerUnaware(object, ea);\r\n  });\r\n}\r\n\r\n/* \r\n * PUBLIC COP Layer Definition\r\n */\r\n\r\nvar globalContextForNamedLayers = {};\r\n\r\n\r\n\r\n// Gloabl Layer Activation\r\nfunction enableLayer(layer) {\r\n  if (GlobalLayers.indexOf(layer) !== -1) {\r\n    return;\r\n  }\r\n  const wasAlreadyActive = currentLayers().includes(layer);\r\n  GlobalLayers.push(layer);\r\n  invalidateLayerComposition();\r\n  if(!wasAlreadyActive) {\r\n    layer._emitActivateCallbacks();\r\n  }\r\n}\r\n\r\nfunction disableLayer(layer) {\r\n  var idx = GlobalLayers.indexOf(layer);\r\n  if (idx < 0) {\r\n    return;\r\n  }\r\n  layer._emitDeactivateCallbacks();\r\n  GlobalLayers.splice(idx, 1);\r\n  invalidateLayerComposition();\r\n}\r\n\r\nfunction proceed(...args) {\r\n  // COP Proceed Function\r\n  var composition = proceedStack[proceedStack.length - 1];\r\n  if (!composition) {\r\n    console.warn('ContextJS: no composition to proceed (stack is empty) ');\r\n    return;\r\n  }\r\n  if (composition.partialMethodIndex == undefined) {\r\n    composition.partialMethodIndex = composition.partialMethods.length - 1;\r\n  }  \r\n  var index = composition.partialMethodIndex;\r\n  var partialMethod = composition.partialMethods[index];\r\n  if (!partialMethod) {\r\n    if (!partialMethod) {\r\n      throw new COPError('no partialMethod to proceed');\r\n    }\r\n  } else {\r\n    composition.partialMethodIndex = index - 1;\r\n    try {\r\n      if (proceedStack.length > 1000) {\r\n        debugger // #Debug\r\n      }\r\n      return invokeNextPartialMethod(partialMethod, index, composition, args);\r\n    } catch(e) {\r\n      console.error(\"proceed \" + proceedStack.length, e)\r\n      debugger // #TODO debug endless recursion!\r\n      return \r\n    }\r\n  }\r\n}\r\n\r\nfunction invokeNextPartialMethod(partialMethod, index, composition, args) {\r\n  try {\r\n    return partialMethod.apply(composition.object, args);\r\n  } finally {\r\n    composition.partialMethodIndex = index;\r\n  }\r\n}\r\n\r\n/* \r\n * Layer Class\r\n */\r\nclass Layer {\r\n  constructor (name, context) {\r\n    this._name = name;\r\n    if (typeof name === 'undefined') {\r\n      this._name = self.Symbol('COP Layer');\r\n    }\r\n    this._context = context;\r\n    // this._layeredFunctionsList = {};\r\n    \r\n    this._activateCallbacks = [];\r\n    this._deactivateCallbacks = [];\r\n  }\r\n  \r\n  // Accessing\r\n  get name () {\r\n    return this._name;\r\n  }\r\n  fullName () {\r\n    return '' + this._context + '.' + this._name;\r\n  }\r\n  layeredObjects () {\r\n    return Object.getOwnPropertyNames(this)\r\n      .map(ea => this[ea] && this[ea]._layered_object)\r\n      .filter(ea => ea); // filters falsy things\r\n  }\r\n  // TODO: doesn't differentiate between functions and classes - necessary?\r\n  layeredClasses () {\r\n    return this.layeredObjects().map(ea => ea.constructor);\r\n  }\r\n  \r\n  // Removing\r\n  remove () {\r\n    // Deletes the LayerClass, but keeps the layered Functions.\r\n    if (this.isGlobal()) {\r\n      this.beNotGlobal();\r\n    }\r\n    implicitLayers.delete(this);\r\n    if(this.AExprForILA) {\r\n      this.AExprForILA.dispose();\r\n    }\r\n\r\n    var context = this._context;\r\n    if (typeof context !== 'undefined')\r\n      delete context[this.name];\r\n  }\r\n  uninstall () {\r\n    // Uninstalls just this Layer.\r\n    // functions that are layered by other Layers will not be reset.\r\n    var layer = this;\r\n    this.layeredObjects().forEach(\r\n      function(eachLayeredObj) {\r\n        // var layerIdx = typeof eachLayeredObj.activeLayers === 'function'\r\n        //     ? eachLayeredObj.activeLayers().indexOf(layer) : -1;\r\n        \r\n        // #Special Lively Webwerkstatt code.... General Case? #Jens\r\n        // #TODO if we have of gloabal list of all layers... we can look there\r\n        \r\n        // Properties.own(layer._layeredFunctionsList[eachLayeredObj]).each(\r\n        //   function(eachLayeredFunc) {\r\n        //     var newerLayer = eachLayeredObj.activeLayers().find(\r\n        //       function(eachOtherLayer) {\r\n        //         var eachOtherLayerIdx\r\n        //             = eachLayeredObj.activeLayers().indexOf(eachOtherLayer);\r\n        //         var isNewer = (eachOtherLayerIdx !== -1)\r\n        //             && (eachOtherLayerIdx < layerIdx);\r\n        //         return isNewer &&\r\n        //             eachOtherLayer._layeredFunctionsList[eachLayeredObj][eachLayeredFunc];\r\n        //       });\r\n        //       if (!newerLayer) {\r\n        //         makeFunctionLayerUnaware(eachLayeredObj, eachLayeredFunc);\r\n        //       }\r\n        //   });\r\n      });\r\n      this.remove();\r\n  }\r\n  \r\n  // Layer installation\r\n  refineClass (classObject, methods) {\r\n    if (!classObject || !classObject.prototype) {\r\n      throw new Error(\"ContextJS: can not refine class '\" + classObject + \"' in \" + this);\r\n    }\r\n    this.refineObject(classObject.prototype, methods);\r\n    return this;\r\n  }\r\n\r\n  // Layering objects may be a garbage collection problem, because the layers keep strong\r\n  // reference to the objects\r\n  refineObject (object, methods) {\r\n    // log(\"cop refineObject\");\r\n\r\n    // Bookkeeping:\r\n    // typeof object.getName === 'function' && (layer._layeredFunctionsList[object] = {});\r\n    Object.getOwnPropertyNames(methods).forEach(function_name => {\r\n      // log(\" layer property: \" + function_name)\r\n      layerProperty(this, object, function_name, methods);\r\n    });\r\n    return this;\r\n  }\r\n  unrefineObject (obj) {\r\n    var id = obj[LayerObjectID];\r\n    if (id !== undefined) {\r\n      delete this[id];\r\n    }\r\n  }\r\n  unrefineClass (classObj) {\r\n    this.unrefineObject(classObj.prototype);\r\n  }\r\n\r\n  reinstallInClass (constructor) {\r\n    this.reinstallInObject(constructor.prototype);\r\n  }\r\n\r\n  reinstallInObject (object) {\r\n    const partialLayer = ensurePartialLayer(this, object);\r\n    partialLayer.reinstall();\r\n  }\r\n  \r\n  // Layer activation\r\n  beGlobal () {\r\n    enableLayer(this);\r\n    return this;\r\n  }\r\n  beNotGlobal () {\r\n    disableLayer(this);\r\n    return this;\r\n  }\r\n  hide () {\r\n    // Hidden Layers do not appear when evaluating the sourcecode of a function\r\n    // TODO: this function has to be called BEFORE the layer refines any class,\r\n    // due to problems in unrefining classes.\r\n    this.isHidden = true;\r\n    return this;\r\n  }\r\n  \r\n  // Testing\r\n  isLayer() {\r\n    return true;\r\n  }\r\n  isGlobal () {\r\n    return GlobalLayers.indexOf(this) !== -1;\r\n  }\r\n  \r\n  // Debugging\r\n  toString () {\r\n    return String(this.name); // could be a symbol\r\n  }\r\n  \r\n  // Life-cycle callbacks\r\n  onActivate(callback) {\r\n    this._activateCallbacks.push(callback);\r\n    this._fallbackToReactiveTrackingOfILA();\r\n    return this;\r\n  }\r\n  onDeactivate(callback) {\r\n    this._deactivateCallbacks.push(callback);\r\n    this._fallbackToReactiveTrackingOfILA();\r\n    return this;\r\n  }\r\n  _emitActivateCallbacks() {\r\n    this._activateCallbacks.forEach(cb => cb());\r\n  }\r\n  _emitDeactivateCallbacks() {\r\n    this._deactivateCallbacks.forEach(cb => cb());\r\n  }\r\n  \r\n  // Implicit Layer Activation\r\n  activeWhile(condition, aexprConstructor) {\r\n    this.implicitlyActivated = condition;\r\n    this.aexprConstructor = aexprConstructor;\r\n    \r\n    implicitLayers.add(this);\r\n    this._fallbackToReactiveTrackingOfILA();\r\n\r\n    return this;\r\n  }\r\n  _fallbackToReactiveTrackingOfILA() {\r\n    if(this._shouldUseReactiveTracking()) {\r\n      this._setupReactiveILA()\r\n    }\r\n  }\r\n  _shouldUseReactiveTracking() {\r\n    return this.implicitlyActivated &&\r\n      this.aexprConstructor &&\r\n      (this._activateCallbacks.length + this._deactivateCallbacks.length > 0);\r\n  }\r\n  _setupReactiveILA() {\r\n    implicitLayers.delete(this);\r\n    \r\n    if(!this.AExprForILA) {\r\n      this.AExprForILA = this.aexprConstructor(this.implicitlyActivated)\r\n          .onBecomeTrue(() => this.beGlobal())\r\n          .onBecomeFalse(() => this.beNotGlobal());\r\n    }\r\n  }\r\n}\r\n\r\nconst implicitLayers = new Set();\r\nfunction getActiveImplicitLayers ( ) {\r\n  return [...implicitLayers]\r\n    .filter(layer => layer.implicitlyActivated());\r\n}\r\n\r\nfunction collectWithLayersIn (layers, result) {\r\n  for (var i = layers.length - 1; i >= 0 ; i--) {\r\n    var ea = layers[i]\r\n    if ((result.withLayers.indexOf(ea) === -1)\r\n        && (result.withoutLayers.indexOf(ea) === -1)) {\r\n      result.withLayers.unshift(ea)\r\n    }\r\n  }\r\n}\r\n\r\nfunction collectWithoutLayersIn (layers, result) {\r\n  for (var i = 0; i < layers.length; i++) {\r\n    var ea = layers[i]\r\n    if (result.withoutLayers.indexOf(ea) === -1) {\r\n      result.withoutLayers.push(ea)\r\n    }\r\n  }\r\n}\r\n\r\nfunction structuralLayers (result, obj) {\r\n  // var allLayers = result.withLayers;\r\n  // var allWithoutLayers = result.withoutLayers;\r\n  // go ownerchain backward and gather all layer activations and deactivations\r\n  while (obj) {\r\n    // don't use accessor methods because of speed... (not measured yet)\r\n    if (obj.withLayers) {\r\n        collectWithLayersIn(obj.withLayers, result);\r\n    }\r\n    if (obj.withoutLayers) {\r\n        collectWithoutLayersIn(obj.withoutLayers, result);\r\n    }      \r\n    // recurse, stop if owner is undefined\r\n    obj = obj.owner; // || obj.parentElement || obj.parentNode\r\n  }\r\n  return result;\r\n}\r\n\r\nfunction aysncLayers (result) {\r\n  // optimized version, that does not use closures and recursion\r\n  var stack = AsyncLayerStack;\r\n  // top down, ignore bottom element\r\n  for (var j = stack.length - 1; j > 0; j--) {\r\n    var current = stack[j];\r\n    if (current.withLayers) {\r\n      collectWithLayersIn(current.withLayers, result);\r\n    }\r\n    if (current.withoutLayers) {\r\n      collectWithoutLayersIn(current.withoutLayers, result);\r\n    }\r\n  }\r\n  return result;\r\n}\r\n\r\nfunction globalLayers (result) {\r\n  collectWithLayersIn(GlobalLayers, result);\r\n  return result;\r\n}\r\n\r\nfunction dynamicLayers (result) {\r\n  // optimized version, that does not use closures and recursion\r\n  var stack = LayerStack;\r\n  // top down, ignore bottom element\r\n  for (var j = stack.length - 1; j > 0; j--) {\r\n    var current = stack[j];\r\n    if (current.withLayers) {\r\n      collectWithLayersIn(current.withLayers, result);\r\n    }\r\n    if (current.withoutLayers) {\r\n      collectWithoutLayersIn(current.withoutLayers, result);\r\n    }\r\n  }\r\n  return result;\r\n}\r\n\r\n\r\n// #TODO #STEFAN rename -> implicitLayers\r\nfunction activeImplicitLayers(result) {\r\n  collectWithLayersIn(getActiveImplicitLayers(), result);\r\n  return result\r\n}\r\n\r\nfunction activeLayers () {\r\n  var result = {withLayers: [], withoutLayers: []};\r\n  // go top to bottom in stack... \r\n  // so the last (dynamically) (de-)activated layers are first...\r\n  // remember withLayers and withoutLayers in result\r\n  // this is a bit to \"clever\" to iterate only once...\r\n  dynamicLayers(result); \r\n  \r\n  // #Idea we can implement structural layer for HTMLElements without having to modify prototype...\r\n  // structuralLayers(result, obj);\r\n  activeImplicitLayers(result); \r\n   \r\n  globalLayers(result);\r\n  // and the global layers are last\r\n  return result.withLayers;\r\n}\r\n\r\n/*\r\n * Example implementation of a layerable object\r\n */\r\nclass LayerableObjectTrait {\r\n  activeLayers (defaultActiveLayersFunc) {\r\n    var result = {withLayers: [], withoutLayers: []};\r\n    // go top to bottom in stack... \r\n    // so the last (dynamically) (de-)activated layers are first...\r\n    // remember withLayers and withoutLayers in result\r\n    // this is a bit to \"clever\" to iterate only once...\r\n    dynamicLayers(result); \r\n    structuralLayers(result, this);\r\n    globalLayers(result);\r\n    // and the global layers are last\r\n    return result.withLayers;\r\n  }\r\n\r\n  setWithLayers (layers) {\r\n    this.withLayers = layers;\r\n  }\r\n  addWithLayer (layer) {\r\n    var layers = this.getWithLayers();\r\n    if (!layers.includes(layer)) {\r\n      this.setWithLayers(layers.concat([layer]));\r\n    }\r\n  }\r\n  removeWithLayer (layer) {\r\n    var layers = this.getWithLayers();\r\n    if (layers.includes(layer)) {\r\n      this.setWithLayers(layers.filter(l => l !== layer));\r\n    }\r\n  }\r\n  addWithoutLayer (layer) {\r\n    var layers = this.getWithoutLayers();\r\n    if (!layers.include(layer)) {\r\n      this.setWithoutLayers(layers.concat([layer]));\r\n    }\r\n  }\r\n  removeWithoutLayer (layer) {\r\n    var layers = this.getWithoutLayers();\r\n    this.setWithoutLayers(layers.filter(l => l !== layer));\r\n  }\r\n  setWithoutLayers (layers) {\r\n    this.withoutLayers = layers;\r\n  }\r\n  getWithLayers () {\r\n    return this.withLayers || [];\r\n  }\r\n  getWithoutLayer () {\r\n    return this.withoutLayers || [];\r\n  }\r\n}\r\n\r\nclass LayerableObject extends LayerableObjectTrait {}\r\n\r\nclass COPError {\r\n  constructor (message) {\r\n    this._msg = message;\r\n  }\r\n  toString () {\r\n    return \"COP ERROR: \" + this._msg;\r\n  }\r\n}\r\n\r\nclass PartialLayerComposition {\r\n  constructor (obj, functionName, baseFunction, methodType) {\r\n    this._partialMethods = [baseFunction];\r\n    var layers = computeLayersFor(obj);\r\n    for (var i = 0; i < layers.length; i++) {\r\n        var layer = layers[i];\r\n        var partialMethod = lookupLayeredFunctionForObject(\r\n            obj, layer, functionName, methodType);\r\n        if (partialMethod) {\r\n          this._partialMethods.push(partialMethod);\r\n        }\r\n    }\r\n    this._object = obj;\r\n  }\r\n\r\n  get object() {\r\n    return this._object;\r\n  }\r\n  \r\n  get partialMethods () {\r\n    return this._partialMethods;\r\n  }\r\n}\r\n\r\nresetLayerStack();\r\n\r\n// vim: sw=2\r\n\n\n//# sourceURL=webpack:///./ContextJS/src/Layers.js?");

/***/ }),

/***/ "./ContextJS/src/contextjs.js":
/*!************************************!*\
  !*** ./ContextJS/src/contextjs.js ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"proceed\": () => /* reexport safe */ _Layers_js__WEBPACK_IMPORTED_MODULE_0__.proceed,\n/* harmony export */   \"Layer\": () => /* reexport safe */ _Layers_js__WEBPACK_IMPORTED_MODULE_0__.Layer,\n/* harmony export */   \"withLayers\": () => /* binding */ withLayers,\n/* harmony export */   \"withoutLayers\": () => /* binding */ withoutLayers,\n/* harmony export */   \"layer\": () => /* binding */ layer\n/* harmony export */ });\n/* harmony import */ var _Layers_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Layers.js */ \"./ContextJS/src/Layers.js\");\n/*\r\n * Copyright (c) 2008-2016 Hasso Plattner Institute\r\n *\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a copy\r\n * of this software and associated documentation files (the \"Software\"), to deal\r\n * in the Software without restriction, including without limitation the rights\r\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n * copies of the Software, and to permit persons to whom the Software is\r\n * furnished to do so, subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n * THE SOFTWARE.\r\n */\r\n \r\n\r\n\r\n\r\n\r\n\r\n// Layer Activation\r\nfunction withLayers(layers, func) {\r\n  const previouslyActiveLayers = (0,_Layers_js__WEBPACK_IMPORTED_MODULE_0__.currentLayers)();\r\n  _Layers_js__WEBPACK_IMPORTED_MODULE_0__.LayerStack.push({withLayers: layers});\r\n  layers\r\n    .filter(l => !previouslyActiveLayers.includes(l))\r\n    .forEach(l => l._emitActivateCallbacks());\r\n  // console.log(\"callee: \" + withLayers.callee);\r\n  try {\r\n    return func();\r\n  } finally {\r\n    const beforePop = (0,_Layers_js__WEBPACK_IMPORTED_MODULE_0__.currentLayers)();\r\n    _Layers_js__WEBPACK_IMPORTED_MODULE_0__.LayerStack.pop();\r\n    const afterPop = (0,_Layers_js__WEBPACK_IMPORTED_MODULE_0__.currentLayers)();\r\n    // #TODO: we should probably .reverse() the list to deactivate the last activated layer first\r\n    layers\r\n      .filter(l => beforePop.includes(l) && !afterPop.includes(l))\r\n      .forEach(l => l._emitDeactivateCallbacks());\r\n  }\r\n}\r\n\r\nfunction withoutLayers(layers, func) {\r\n  const beforePush = (0,_Layers_js__WEBPACK_IMPORTED_MODULE_0__.currentLayers)();\r\n  _Layers_js__WEBPACK_IMPORTED_MODULE_0__.LayerStack.push({withoutLayers: layers});\r\n  layers\r\n    .filter(l => beforePush.includes(l))\r\n    .forEach(l => l._emitDeactivateCallbacks());\r\n  try {\r\n    return func();\r\n  } finally {\r\n    const beforePop = (0,_Layers_js__WEBPACK_IMPORTED_MODULE_0__.currentLayers)();\r\n    _Layers_js__WEBPACK_IMPORTED_MODULE_0__.LayerStack.pop();\r\n    const afterPop = (0,_Layers_js__WEBPACK_IMPORTED_MODULE_0__.currentLayers)();\r\n    // #TODO: we should probably .reverse() the list to deactivate the last activated layer first\r\n    layers\r\n      .filter(l => !beforePop.includes(l) && afterPop.includes(l))\r\n      .forEach(l => l._emitActivateCallbacks());\r\n  }\r\n}\r\n\r\n// Layer creation by name\r\nfunction layer(...args) {\r\n  let layerName, context;\r\n  if (args.length === 2) {\r\n    [context, layerName] = args;\r\n  } else if (args.length === 1) {\r\n    [layerName] = args;\r\n  }\r\n  return basicCreate(layerName, context);\r\n};\r\n\r\n// Private helpers\r\nfunction basicCreate(layerName, context) {\r\n  if (typeof context === 'undefined')\r\n    context = _Layers_js__WEBPACK_IMPORTED_MODULE_0__.GlobalNamedLayers;\r\n  if (typeof context[layerName] !== 'undefined') {\r\n    let existing = context[layerName];\r\n    if (!existing.isLayer /* undefined or falsy */ || !existing.isLayer()) {\r\n      throw new Error('Will not overwrite existing property ' + layerName);\r\n    }\r\n    return existing;\r\n  } else {\r\n    return context[layerName] = new _Layers_js__WEBPACK_IMPORTED_MODULE_0__.Layer(layerName, context);\r\n  }\r\n};\r\n\n\n//# sourceURL=webpack:///./ContextJS/src/contextjs.js?");

/***/ }),

/***/ "./context-zone/contextZone.js":
/*!*************************************!*\
  !*** ./context-zone/contextZone.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"withLayersZone\": () => /* binding */ withLayersZone,\n/* harmony export */   \"withoutLayersZone\": () => /* binding */ withoutLayersZone\n/* harmony export */ });\n/* harmony import */ var _ContextJS_src_contextjs_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../ContextJS/src/contextjs.js */ \"./ContextJS/src/contextjs.js\");\n/* harmony import */ var _microTaskZone_helpers_psd_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./microTaskZone/helpers/psd.js */ \"./context-zone/microTaskZone/helpers/psd.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils.js */ \"./context-zone/utils.js\");\n// node --experimental-modules zoneContextJS.js\r\n\r\n\r\n\r\n\r\n\r\nconst withFrame = (frame, activateCallback) => {\r\n  const zoneName = (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.generateZoneName)();\r\n\r\n  const onInvokeTaskCallback = (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.generateOnInvokeTaskCallback)(frame, zoneName);\r\n  const zone = Zone.current.fork({\r\n    name: zoneName,\r\n    onInvokeTask: onInvokeTaskCallback,\r\n  });\r\n\r\n  activateCallback(zone);\r\n}\r\n\r\nconst withFrameZone = (layers, callback, isActivation) => {\r\n  const frame = { [isActivation ? \"withLayers\" : \"withoutLayers\"]: layers };\r\n  const withDynamicExtent = isActivation ? _ContextJS_src_contextjs_js__WEBPACK_IMPORTED_MODULE_0__.withLayers : _ContextJS_src_contextjs_js__WEBPACK_IMPORTED_MODULE_0__.withoutLayers;\r\n  let returnValue;\r\n\r\n  withFrame(frame, (zone) => {\r\n    const [restoreLayerStack, unrestoreLayerStack] = (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.useReplayLayerStack)(frame, zone.name);\r\n    const [replayZoneCurrentEnter, replayZoneCurrentLeave] = (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.useReplayZoneCurrent)(zone, Zone.current);\r\n\r\n    withDynamicExtent(layers, () => {\r\n      zone.run(() => {\r\n        try {\r\n          (0,_microTaskZone_helpers_psd_js__WEBPACK_IMPORTED_MODULE_1__.incrementExpectedAwaits)();\r\n\r\n          (0,_microTaskZone_helpers_psd_js__WEBPACK_IMPORTED_MODULE_1__.microTaskScope)(() => {\r\n            returnValue = callback.call();\r\n          }, {\r\n            afterEnter() {\r\n              restoreLayerStack();\r\n              replayZoneCurrentEnter();\r\n            },\r\n            afterLeave() {\r\n              unrestoreLayerStack();\r\n              replayZoneCurrentLeave();\r\n            },\r\n          });\r\n        } finally {\r\n          if (returnValue && typeof returnValue.then === \"function\") {\r\n            returnValue.then(() => (0,_microTaskZone_helpers_psd_js__WEBPACK_IMPORTED_MODULE_1__.decrementExpectedAwaits)());\r\n          } else {\r\n            (0,_microTaskZone_helpers_psd_js__WEBPACK_IMPORTED_MODULE_1__.decrementExpectedAwaits)();\r\n          }\r\n        }\r\n      });\r\n    });\r\n  });\r\n}\r\n\r\nconst withLayersZone = (layers, callback) => {\r\n  withFrameZone(layers, callback, true);\r\n}\r\n\r\nconst withoutLayersZone = (layers, callback) => {\r\n  withFrameZone(layers, callback, false);\r\n}\n\n//# sourceURL=webpack:///./context-zone/contextZone.js?");

/***/ }),

/***/ "./context-zone/microTaskZone/errors/errors.js":
/*!*****************************************************!*\
  !*** ./context-zone/microTaskZone/errors/errors.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"DexieError\": () => /* binding */ DexieError,\n/* harmony export */   \"ModifyError\": () => /* binding */ ModifyError,\n/* harmony export */   \"BulkError\": () => /* binding */ BulkError,\n/* harmony export */   \"errnames\": () => /* binding */ errnames,\n/* harmony export */   \"exceptions\": () => /* binding */ exceptions,\n/* harmony export */   \"exceptionMap\": () => /* binding */ exceptionMap,\n/* harmony export */   \"mapError\": () => /* binding */ mapError,\n/* harmony export */   \"fullNameExceptions\": () => /* binding */ fullNameExceptions\n/* harmony export */ });\n/* harmony import */ var _functions_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../functions/utils.js */ \"./context-zone/microTaskZone/functions/utils.js\");\n/* harmony import */ var _helpers_debug_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../helpers/debug.js */ \"./context-zone/microTaskZone/helpers/debug.js\");\n\r\n\r\n\r\nvar dexieErrorNames = [\r\n    'Modify',\r\n    'Bulk',\r\n    'OpenFailed',\r\n    'VersionChange',\r\n    'Schema',\r\n    'Upgrade',\r\n    'InvalidTable',\r\n    'MissingAPI',\r\n    'NoSuchDatabase',\r\n    'InvalidArgument',\r\n    'SubTransaction',\r\n    'Unsupported',\r\n    'Internal',\r\n    'DatabaseClosed',\r\n    'PrematureCommit',\r\n    'ForeignAwait'\r\n];\r\n\r\nvar idbDomErrorNames = [\r\n    'Unknown',\r\n    'Constraint',\r\n    'Data',\r\n    'TransactionInactive',\r\n    'ReadOnly',\r\n    'Version',\r\n    'NotFound',\r\n    'InvalidState',\r\n    'InvalidAccess',\r\n    'Abort',\r\n    'Timeout',\r\n    'QuotaExceeded',\r\n    'Syntax',\r\n    'DataClone'\r\n];\r\n\r\nvar errorList = dexieErrorNames.concat(idbDomErrorNames);\r\n\r\nvar defaultTexts = {\r\n    VersionChanged: \"Database version changed by other database connection\",\r\n    DatabaseClosed: \"Database has been closed\",\r\n    Abort: \"Transaction aborted\",\r\n    TransactionInactive: \"Transaction has already completed or failed\"\r\n};\r\n\r\n//\r\n// DexieError - base class of all out exceptions.\r\n//\r\nfunction DexieError (name, msg) {\r\n    // Reason we don't use ES6 classes is because:\r\n    // 1. It bloats transpiled code and increases size of minified code.\r\n    // 2. It doesn't give us much in this case.\r\n    // 3. It would require sub classes to call super(), which\r\n    //    is not needed when deriving from Error.\r\n    this._e = (0,_helpers_debug_js__WEBPACK_IMPORTED_MODULE_1__.getErrorWithStack)();\r\n    this.name = name;\r\n    this.message = msg;\r\n}\r\n\r\n(0,_functions_utils_js__WEBPACK_IMPORTED_MODULE_0__.derive)(DexieError).from(Error).extend({\r\n    stack: {\r\n        get: function() {\r\n            return this._stack ||\r\n                (this._stack = this.name + \": \" + this.message + (0,_helpers_debug_js__WEBPACK_IMPORTED_MODULE_1__.prettyStack)(this._e, 2));\r\n        }\r\n    },\r\n    toString: function(){ return this.name + \": \" + this.message; }\r\n});\r\n\r\nfunction getMultiErrorMessage (msg, failures) {\r\n    return msg + \". Errors: \" + Object.keys(failures)\r\n        .map(key=>failures[key].toString())\r\n        .filter((v,i,s)=>s.indexOf(v) === i) // Only unique error strings\r\n        .join('\\n');\r\n}\r\n\r\n//\r\n// ModifyError - thrown in Collection.modify()\r\n// Specific constructor because it contains members failures and failedKeys.\r\n//\r\nfunction ModifyError (msg, failures, successCount, failedKeys) {\r\n    this._e = (0,_helpers_debug_js__WEBPACK_IMPORTED_MODULE_1__.getErrorWithStack)();\r\n    this.failures = failures;\r\n    this.failedKeys = failedKeys;\r\n    this.successCount = successCount;\r\n    this.message = getMultiErrorMessage(msg, failures);\r\n}\r\n(0,_functions_utils_js__WEBPACK_IMPORTED_MODULE_0__.derive)(ModifyError).from(DexieError);\r\n\r\nfunction BulkError (msg, failures) {\r\n    this._e = (0,_helpers_debug_js__WEBPACK_IMPORTED_MODULE_1__.getErrorWithStack)();\r\n    this.name = \"BulkError\";\r\n    this.failures = failures;\r\n    this.message = getMultiErrorMessage(msg, failures);\r\n}\r\n(0,_functions_utils_js__WEBPACK_IMPORTED_MODULE_0__.derive)(BulkError).from(DexieError);\r\n\r\n//\r\n//\r\n// Dynamically generate error names and exception classes based\r\n// on the names in errorList.\r\n//\r\n//\r\n\r\n// Map of {ErrorName -> ErrorName + \"Error\"}\r\nvar errnames = errorList.reduce((obj,name)=>(obj[name]=name+\"Error\",obj),{});\r\n\r\n// Need an alias for DexieError because we're gonna create subclasses with the same name.\r\nconst BaseException = DexieError;\r\n// Map of {ErrorName -> exception constructor}\r\nvar exceptions = errorList.reduce((obj,name)=>{\r\n    // Let the name be \"DexieError\" because this name may\r\n    // be shown in call stack and when debugging. DexieError is\r\n    // the most true name because it derives from DexieError,\r\n    // and we cannot change Function.name programatically without\r\n    // dynamically create a Function object, which would be considered\r\n    // 'eval-evil'.\r\n    var fullName = name + \"Error\";\r\n    function DexieError (msgOrInner, inner){\r\n        this._e = (0,_helpers_debug_js__WEBPACK_IMPORTED_MODULE_1__.getErrorWithStack)();\r\n        this.name = fullName;\r\n        if (!msgOrInner) {\r\n            this.message = defaultTexts[name] || fullName;\r\n            this.inner = null;\r\n        } else if (typeof msgOrInner === 'string') {\r\n            this.message = `${msgOrInner}${!inner ? '' : '\\n ' + inner}`;\r\n            this.inner = inner || null;\r\n        } else if (typeof msgOrInner === 'object') {\r\n            this.message = `${msgOrInner.name} ${msgOrInner.message}`;\r\n            this.inner = msgOrInner;\r\n        }\r\n    }\r\n    (0,_functions_utils_js__WEBPACK_IMPORTED_MODULE_0__.derive)(DexieError).from(BaseException);\r\n    obj[name]=DexieError;\r\n    return obj;\r\n},{});\r\n\r\n// Use ECMASCRIPT standard exceptions where applicable:\r\nexceptions.Syntax = SyntaxError;\r\nexceptions.Type = TypeError;\r\nexceptions.Range = RangeError;\r\n\r\nvar exceptionMap = idbDomErrorNames.reduce((obj, name)=>{\r\n    obj[name + \"Error\"] = exceptions[name];\r\n    return obj;\r\n}, {});\r\n\r\nfunction mapError (domError, message) {\r\n    if (!domError || domError instanceof DexieError || domError instanceof TypeError || domError instanceof SyntaxError || !domError.name || !exceptionMap[domError.name])\r\n        return domError;\r\n    var rv = new exceptionMap[domError.name](message || domError.message, domError);\r\n    if (\"stack\" in domError) {\r\n        // Derive stack from inner exception if it has a stack\r\n        (0,_functions_utils_js__WEBPACK_IMPORTED_MODULE_0__.setProp)(rv, \"stack\", {get: function(){\r\n            return this.inner.stack;\r\n        }});\r\n    }\r\n    return rv;\r\n}\r\n\r\nvar fullNameExceptions = errorList.reduce((obj, name)=>{\r\n    if ([\"Syntax\",\"Type\",\"Range\"].indexOf(name) === -1)\r\n        obj[name + \"Error\"] = exceptions[name];\r\n    return obj;\r\n}, {});\r\n\r\nfullNameExceptions.ModifyError = ModifyError;\r\nfullNameExceptions.DexieError = DexieError;\r\nfullNameExceptions.BulkError = BulkError;\r\n\n\n//# sourceURL=webpack:///./context-zone/microTaskZone/errors/errors.js?");

/***/ }),

/***/ "./context-zone/microTaskZone/functions/chaining-functions.js":
/*!********************************************************************!*\
  !*** ./context-zone/microTaskZone/functions/chaining-functions.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"nop\": () => /* binding */ nop,\n/* harmony export */   \"mirror\": () => /* binding */ mirror,\n/* harmony export */   \"pureFunctionChain\": () => /* binding */ pureFunctionChain,\n/* harmony export */   \"callBoth\": () => /* binding */ callBoth,\n/* harmony export */   \"hookCreatingChain\": () => /* binding */ hookCreatingChain,\n/* harmony export */   \"hookDeletingChain\": () => /* binding */ hookDeletingChain,\n/* harmony export */   \"hookUpdatingChain\": () => /* binding */ hookUpdatingChain,\n/* harmony export */   \"reverseStoppableEventChain\": () => /* binding */ reverseStoppableEventChain,\n/* harmony export */   \"nonStoppableEventChain\": () => /* binding */ nonStoppableEventChain,\n/* harmony export */   \"promisableChain\": () => /* binding */ promisableChain\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"./context-zone/microTaskZone/functions/utils.js\");\n\r\n\r\nfunction nop() { }\r\nfunction mirror(val) { return val; }\r\nfunction pureFunctionChain(f1, f2) {\r\n    // Enables chained events that takes ONE argument and returns it to the next function in chain.\r\n    // This pattern is used in the hook(\"reading\") event.\r\n    if (f1 == null || f1 === mirror) return f2;\r\n    return function (val) {\r\n        return f2(f1(val));\r\n    };\r\n}\r\n\r\nfunction callBoth(on1, on2) {\r\n    return function () {\r\n        on1.apply(this, arguments);\r\n        on2.apply(this, arguments);\r\n    };\r\n}\r\n\r\nfunction hookCreatingChain(f1, f2) {\r\n    // Enables chained events that takes several arguments and may modify first argument by making a modification and then returning the same instance.\r\n    // This pattern is used in the hook(\"creating\") event.\r\n    if (f1 === nop) return f2;\r\n    return function () {\r\n        var res = f1.apply(this, arguments);\r\n        if (res !== undefined) arguments[0] = res;\r\n        var onsuccess = this.onsuccess, // In case event listener has set this.onsuccess\r\n            onerror = this.onerror;     // In case event listener has set this.onerror\r\n        this.onsuccess = null;\r\n        this.onerror = null;\r\n        var res2 = f2.apply(this, arguments);\r\n        if (onsuccess) this.onsuccess = this.onsuccess ? callBoth(onsuccess, this.onsuccess) : onsuccess;\r\n        if (onerror) this.onerror = this.onerror ? callBoth(onerror, this.onerror) : onerror;\r\n        return res2 !== undefined ? res2 : res;\r\n    };\r\n}\r\n\r\nfunction hookDeletingChain(f1, f2) {\r\n    if (f1 === nop) return f2;\r\n    return function () {\r\n        f1.apply(this, arguments);\r\n        var onsuccess = this.onsuccess, // In case event listener has set this.onsuccess\r\n            onerror = this.onerror;     // In case event listener has set this.onerror\r\n        this.onsuccess = this.onerror = null;\r\n        f2.apply(this, arguments);\r\n        if (onsuccess) this.onsuccess = this.onsuccess ? callBoth(onsuccess, this.onsuccess) : onsuccess;\r\n        if (onerror) this.onerror = this.onerror ? callBoth(onerror, this.onerror) : onerror;\r\n    };\r\n}\r\n\r\nfunction hookUpdatingChain(f1, f2) {\r\n    if (f1 === nop) return f2;\r\n    return function (modifications) {\r\n        var res = f1.apply(this, arguments);\r\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.extend)(modifications, res); // If f1 returns new modifications, extend caller's modifications with the result before calling next in chain.\r\n        var onsuccess = this.onsuccess, // In case event listener has set this.onsuccess\r\n            onerror = this.onerror;     // In case event listener has set this.onerror\r\n        this.onsuccess = null;\r\n        this.onerror = null;\r\n        var res2 = f2.apply(this, arguments);\r\n        if (onsuccess) this.onsuccess = this.onsuccess ? callBoth(onsuccess, this.onsuccess) : onsuccess;\r\n        if (onerror) this.onerror = this.onerror ? callBoth(onerror, this.onerror) : onerror;\r\n        return res === undefined ?\r\n            (res2 === undefined ? undefined : res2) :\r\n            ((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.extend)(res, res2));\r\n    };\r\n}\r\n\r\nfunction reverseStoppableEventChain(f1, f2) {\r\n    if (f1 === nop) return f2;\r\n    return function () {\r\n        if (f2.apply(this, arguments) === false) return false;\r\n        return f1.apply(this, arguments);\r\n    };\r\n}\r\n\r\nfunction nonStoppableEventChain(f1, f2) {\r\n    if (f1 === nop) return f2;\r\n    return function () {\r\n        f1.apply(this, arguments);\r\n        f2.apply(this, arguments);\r\n    };\r\n}\r\n\r\nfunction promisableChain(f1, f2) {\r\n    if (f1 === nop) return f2;\r\n    return function () {\r\n        var res = f1.apply(this, arguments);\r\n        if (res && typeof res.then === 'function') {\r\n            var thiz = this,\r\n                i = arguments.length,\r\n                args = new Array(i);\r\n            while (i--) args[i] = arguments[i];\r\n            return res.then(function () {\r\n                return f2.apply(thiz, args);\r\n            });\r\n        }\r\n        return f2.apply(this, arguments);\r\n    };\r\n}\r\n\n\n//# sourceURL=webpack:///./context-zone/microTaskZone/functions/chaining-functions.js?");

/***/ }),

/***/ "./context-zone/microTaskZone/functions/utils.js":
/*!*******************************************************!*\
  !*** ./context-zone/microTaskZone/functions/utils.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"keys\": () => /* binding */ keys,\n/* harmony export */   \"isArray\": () => /* binding */ isArray,\n/* harmony export */   \"_global\": () => /* binding */ _global,\n/* harmony export */   \"extend\": () => /* binding */ extend,\n/* harmony export */   \"getProto\": () => /* binding */ getProto,\n/* harmony export */   \"_hasOwn\": () => /* binding */ _hasOwn,\n/* harmony export */   \"hasOwn\": () => /* binding */ hasOwn,\n/* harmony export */   \"props\": () => /* binding */ props,\n/* harmony export */   \"defineProperty\": () => /* binding */ defineProperty,\n/* harmony export */   \"setProp\": () => /* binding */ setProp,\n/* harmony export */   \"derive\": () => /* binding */ derive,\n/* harmony export */   \"getOwnPropertyDescriptor\": () => /* binding */ getOwnPropertyDescriptor,\n/* harmony export */   \"getPropertyDescriptor\": () => /* binding */ getPropertyDescriptor,\n/* harmony export */   \"slice\": () => /* binding */ slice,\n/* harmony export */   \"override\": () => /* binding */ override,\n/* harmony export */   \"assert\": () => /* binding */ assert,\n/* harmony export */   \"asap\": () => /* binding */ asap,\n/* harmony export */   \"getUniqueArray\": () => /* binding */ getUniqueArray,\n/* harmony export */   \"arrayToObject\": () => /* binding */ arrayToObject,\n/* harmony export */   \"trycatcher\": () => /* binding */ trycatcher,\n/* harmony export */   \"tryCatch\": () => /* binding */ tryCatch,\n/* harmony export */   \"getByKeyPath\": () => /* binding */ getByKeyPath,\n/* harmony export */   \"setByKeyPath\": () => /* binding */ setByKeyPath,\n/* harmony export */   \"delByKeyPath\": () => /* binding */ delByKeyPath,\n/* harmony export */   \"shallowClone\": () => /* binding */ shallowClone,\n/* harmony export */   \"flatten\": () => /* binding */ flatten,\n/* harmony export */   \"deepClone\": () => /* binding */ deepClone,\n/* harmony export */   \"toStringTag\": () => /* binding */ toStringTag,\n/* harmony export */   \"getValueOf\": () => /* binding */ getValueOf,\n/* harmony export */   \"getObjectDiff\": () => /* binding */ getObjectDiff,\n/* harmony export */   \"iteratorSymbol\": () => /* binding */ iteratorSymbol,\n/* harmony export */   \"getIteratorOf\": () => /* binding */ getIteratorOf,\n/* harmony export */   \"NO_CHAR_ARRAY\": () => /* binding */ NO_CHAR_ARRAY,\n/* harmony export */   \"getArrayOf\": () => /* binding */ getArrayOf,\n/* harmony export */   \"isAsyncFunction\": () => /* binding */ isAsyncFunction\n/* harmony export */ });\n﻿const keys = Object.keys;\r\nconst isArray = Array.isArray;\r\nconst _global =\r\n    typeof self !== 'undefined' ? self :\r\n    typeof window !== 'undefined' ? window :\r\n    __webpack_require__.g;\r\nif (typeof Promise !== 'undefined' && !_global.Promise){\r\n    // In jsdom, this it can be the case that Promise is not put on the global object.\r\n    // If so, we need to patch the global object for the rest of the code to work as expected.\r\n    // Other dexie code expects Promise to be on the global object (like normal browser environments)\r\n    _global.Promise = Promise;\r\n}\r\n\r\n\r\nfunction extend(obj, extension) {\r\n    if (typeof extension !== 'object') return obj;\r\n    keys(extension).forEach(function (key) {\r\n        obj[key] = extension[key];\r\n    });\r\n    return obj;\r\n}\r\n\r\nconst getProto = Object.getPrototypeOf;\r\nconst _hasOwn = {}.hasOwnProperty;\r\nfunction hasOwn(obj, prop) {\r\n    return _hasOwn.call(obj, prop);\r\n}\r\n\r\nfunction props (proto, extension) {\r\n    if (typeof extension === 'function') extension = extension(getProto(proto));\r\n    keys(extension).forEach(key => {\r\n        setProp(proto, key, extension[key]);\r\n    });\r\n}\r\n\r\nconst defineProperty = Object.defineProperty;\r\n\r\nfunction setProp(obj, prop, functionOrGetSet, options) {\r\n    defineProperty(obj, prop, extend(functionOrGetSet && hasOwn(functionOrGetSet, \"get\") && typeof functionOrGetSet.get === 'function' ?\r\n        {get: functionOrGetSet.get, set: functionOrGetSet.set, configurable: true} :\r\n        {value: functionOrGetSet, configurable: true, writable: true}, options));\r\n}\r\n\r\nfunction derive(Child) {\r\n    return {\r\n        from: function (Parent) {\r\n            Child.prototype = Object.create(Parent.prototype);\r\n            setProp(Child.prototype, \"constructor\", Child);\r\n            return {\r\n                extend: props.bind(null, Child.prototype)\r\n            };\r\n        }\r\n    };\r\n}\r\n\r\nconst getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\r\n\r\nfunction getPropertyDescriptor(obj, prop) {\r\n    const pd = getOwnPropertyDescriptor(obj, prop);\r\n    let proto;\r\n    return pd || (proto = getProto(obj)) && getPropertyDescriptor (proto, prop);\r\n}\r\n\r\nconst _slice = [].slice;\r\nfunction slice(args, start, end) {\r\n    return _slice.call(args, start, end);\r\n}\r\n\r\nfunction override(origFunc, overridedFactory) {\r\n    return overridedFactory(origFunc);\r\n}\r\n\r\nfunction assert (b) {\r\n    if (!b) throw new Error(\"Assertion Failed\");\r\n}\r\n\r\nfunction asap(fn) {\r\n    // @ts-ignore\r\n    if (_global.setImmediate) setImmediate(fn); else setTimeout(fn, 0);\r\n}\r\n\r\nfunction getUniqueArray(a) {\r\n    return a.filter((value, index, self) => self.indexOf(value) === index);\r\n}\r\n\r\n/** Generate an object (hash map) based on given array.\r\n * @param extractor Function taking an array item and its index and returning an array of 2 items ([key, value]) to\r\n *        instert on the resulting object for each item in the array. If this function returns a falsy value, the\r\n *        current item wont affect the resulting object.\r\n */\r\nfunction arrayToObject (array, extractor) {\r\n    return array.reduce((result, item, i) => {\r\n        var nameAndValue = extractor(item, i);\r\n        if (nameAndValue) result[nameAndValue[0]] = nameAndValue[1];\r\n        return result;\r\n    }, {});\r\n}\r\n\r\nfunction trycatcher(fn, reject) {\r\n    return function () {\r\n        try {\r\n            fn.apply(this, arguments);\r\n        } catch (e) {\r\n            reject(e);\r\n        }\r\n    };\r\n}\r\n\r\nfunction tryCatch(fn, onerror, args) {\r\n    try {\r\n        fn.apply(null, args);\r\n    } catch (ex) {\r\n        onerror && onerror(ex);\r\n    }\r\n}\r\n\r\nfunction getByKeyPath(obj, keyPath) {\r\n    // http://www.w3.org/TR/IndexedDB/#steps-for-extracting-a-key-from-a-value-using-a-key-path\r\n    if (hasOwn(obj, keyPath)) return obj[keyPath]; // This line is moved from last to first for optimization purpose.\r\n    if (!keyPath) return obj;\r\n    if (typeof keyPath !== 'string') {\r\n        var rv = [];\r\n        for (var i = 0, l = keyPath.length; i < l; ++i) {\r\n            var val = getByKeyPath(obj, keyPath[i]);\r\n            rv.push(val);\r\n        }\r\n        return rv;\r\n    }\r\n    var period = keyPath.indexOf('.');\r\n    if (period !== -1) {\r\n        var innerObj = obj[keyPath.substr(0, period)];\r\n        return innerObj === undefined ? undefined : getByKeyPath(innerObj, keyPath.substr(period + 1));\r\n    }\r\n    return undefined;\r\n}\r\n\r\nfunction setByKeyPath(obj, keyPath, value) {\r\n    if (!obj || keyPath === undefined) return;\r\n    if ('isFrozen' in Object && Object.isFrozen(obj)) return;\r\n    if (typeof keyPath !== 'string' && 'length' in keyPath) {\r\n        assert(typeof value !== 'string' && 'length' in value);\r\n        for (var i = 0, l = keyPath.length; i < l; ++i) {\r\n            setByKeyPath(obj, keyPath[i], value[i]);\r\n        }\r\n    } else {\r\n        var period = keyPath.indexOf('.');\r\n        if (period !== -1) {\r\n            var currentKeyPath = keyPath.substr(0, period);\r\n            var remainingKeyPath = keyPath.substr(period + 1);\r\n            if (remainingKeyPath === \"\")\r\n                if (value === undefined) {\r\n                    if (isArray(obj) && !isNaN(parseInt(currentKeyPath))) obj.splice(currentKeyPath, 1);\r\n                    else delete obj[currentKeyPath];\r\n                } else obj[currentKeyPath] = value;\r\n            else {\r\n                var innerObj = obj[currentKeyPath];\r\n                if (!innerObj) innerObj = (obj[currentKeyPath] = {});\r\n                setByKeyPath(innerObj, remainingKeyPath, value);\r\n            }\r\n        } else {\r\n            if (value === undefined) {\r\n                if (isArray(obj) && !isNaN(parseInt(keyPath))) obj.splice(keyPath, 1);\r\n                else delete obj[keyPath];\r\n            } else obj[keyPath] = value;\r\n        }\r\n    }\r\n}\r\n\r\nfunction delByKeyPath(obj, keyPath) {\r\n    if (typeof keyPath === 'string')\r\n        setByKeyPath(obj, keyPath, undefined);\r\n    else if ('length' in keyPath)\r\n        [].map.call(keyPath, function(kp) {\r\n            setByKeyPath(obj, kp, undefined);\r\n        });\r\n}\r\n\r\nfunction shallowClone(obj) {\r\n    var rv = {};\r\n    for (var m in obj) {\r\n        if (hasOwn(obj, m)) rv[m] = obj[m];\r\n    }\r\n    return rv;\r\n}\r\n\r\nconst concat = [].concat;\r\nfunction flatten(a) {\r\n    return concat.apply([], a);\r\n}\r\n\r\n//https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm\r\nconst intrinsicTypeNames =\r\n    \"Boolean,String,Date,RegExp,Blob,File,FileList,ArrayBuffer,DataView,Uint8ClampedArray,ImageData,Map,Set\"\r\n    .split(',').concat(\r\n        flatten([8,16,32,64].map(num=>[\"Int\",\"Uint\",\"Float\"].map(t=>t+num+\"Array\")))\r\n    ).filter(t=>_global[t]);\r\nconst intrinsicTypes = intrinsicTypeNames.map(t=>_global[t]);\r\nconst intrinsicTypeNameSet = arrayToObject(intrinsicTypeNames, x=>[x,true]);\r\n\r\nfunction deepClone(any) {\r\n    if (!any || typeof any !== 'object') return any;\r\n    var rv;\r\n    if (isArray(any)) {\r\n        rv = [];\r\n        for (var i = 0, l = any.length; i < l; ++i) {\r\n            rv.push(deepClone(any[i]));\r\n        }\r\n    } else if (intrinsicTypes.indexOf(any.constructor) >= 0) {\r\n        rv = any;\r\n    } else {\r\n        rv = any.constructor ? Object.create(any.constructor.prototype) : {};\r\n        for (var prop in any) {\r\n            if (hasOwn(any, prop)) {\r\n                rv[prop] = deepClone(any[prop]);\r\n            }\r\n        }\r\n    }\r\n    return rv;\r\n}\r\n\r\nconst {toString} = {};\r\nfunction toStringTag(o) {\r\n    return toString.call(o).slice(8, -1);\r\n}\r\n\r\nconst getValueOf = (val, type) =>\r\n    type === \"Array\" ? ''+val.map(v => getValueOf(v, toStringTag(v))) :\r\n    type === \"ArrayBuffer\" ? ''+new Uint8Array(val) :\r\n    type === \"Date\" ? val.getTime() :\r\n    ArrayBuffer.isView(val) ? ''+new Uint8Array(val.buffer) :\r\n    val;\r\n\r\n function getObjectDiff(a, b, rv, prfx) {\r\n    // Compares objects a and b and produces a diff object.\r\n    rv = rv || {};\r\n    prfx = prfx || '';\r\n    keys(a).forEach(prop => {\r\n        if (!hasOwn(b, prop))\r\n            rv[prfx+prop] = undefined; // Property removed\r\n        else {\r\n            var ap = a[prop],\r\n                bp = b[prop];\r\n            if (typeof ap === 'object' && typeof bp === 'object' && ap && bp)\r\n            {\r\n                const apTypeName = toStringTag(ap);\r\n                const bpTypeName = toStringTag(bp);\r\n\r\n                if (apTypeName === bpTypeName) {\r\n                    if (intrinsicTypeNameSet[apTypeName]) {\r\n                        // This is an intrinsic type. Don't go deep diffing it.\r\n                        // Instead compare its value in best-effort:\r\n                        // (Can compare real values of Date, ArrayBuffers and views)\r\n                        if (getValueOf(ap, apTypeName) !== getValueOf(bp, bpTypeName)) {\r\n                            rv[prfx + prop] = b[prop]; // Date / ArrayBuffer etc is of different value\r\n                        }\r\n                    } else {\r\n                        // This is not an intrinsic object. Compare the it deeply:\r\n                        getObjectDiff(ap, bp, rv, prfx + prop + \".\");\r\n                    }\r\n                } else {\r\n                    rv[prfx + prop] = b[prop];// Property changed to other type\r\n                }                \r\n            } else if (ap !== bp)\r\n                rv[prfx + prop] = b[prop];// Primitive value changed\r\n        }\r\n    });\r\n    keys(b).forEach(prop => {\r\n        if (!hasOwn(a, prop)) {\r\n            rv[prfx+prop] = b[prop]; // Property added\r\n        }\r\n    });\r\n    return rv;\r\n}\r\n\r\n// If first argument is iterable or array-like, return it as an array\r\nconst iteratorSymbol = typeof Symbol !== 'undefined' && Symbol.iterator;\r\nconst getIteratorOf = iteratorSymbol ? function(x) {\r\n    var i;\r\n    return x != null && (i = x[iteratorSymbol]) && i.apply(x);\r\n} : function () { return null; };\r\n\r\nconst NO_CHAR_ARRAY = {};\r\n// Takes one or several arguments and returns an array based on the following criteras:\r\n// * If several arguments provided, return arguments converted to an array in a way that\r\n//   still allows javascript engine to optimize the code.\r\n// * If single argument is an array, return a clone of it.\r\n// * If this-pointer equals NO_CHAR_ARRAY, don't accept strings as valid iterables as a special\r\n//   case to the two bullets below.\r\n// * If single argument is an iterable, convert it to an array and return the resulting array.\r\n// * If single argument is array-like (has length of type number), convert it to an array.\r\nfunction getArrayOf (arrayLike) {\r\n    var i, a, x, it;\r\n    if (arguments.length === 1) {\r\n        if (isArray(arrayLike)) return arrayLike.slice();\r\n        if (this === NO_CHAR_ARRAY && typeof arrayLike === 'string') return [arrayLike];\r\n        if ((it = getIteratorOf(arrayLike))) {\r\n            a = [];\r\n            while ((x = it.next()), !x.done) a.push(x.value);\r\n            return a;\r\n        }\r\n        if (arrayLike == null) return [arrayLike];\r\n        i = arrayLike.length;\r\n        if (typeof i === 'number') {\r\n            a = new Array(i);\r\n            while (i--) a[i] = arrayLike[i];\r\n            return a;\r\n        }\r\n        return [arrayLike];\r\n    }\r\n    i = arguments.length;\r\n    a = new Array(i);\r\n    while (i--) a[i] = arguments[i];\r\n    return a;\r\n}\r\nconst isAsyncFunction = typeof Symbol !== 'undefined'\r\n    ? (fn) => fn[Symbol.toStringTag] === 'AsyncFunction'\r\n    : ()=>false;\r\n\n\n//# sourceURL=webpack:///./context-zone/microTaskZone/functions/utils.js?");

/***/ }),

/***/ "./context-zone/microTaskZone/helpers/debug.js":
/*!*****************************************************!*\
  !*** ./context-zone/microTaskZone/helpers/debug.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"debug\": () => /* binding */ debug,\n/* harmony export */   \"setDebug\": () => /* binding */ setDebug,\n/* harmony export */   \"libraryFilter\": () => /* binding */ libraryFilter,\n/* harmony export */   \"NEEDS_THROW_FOR_STACK\": () => /* binding */ NEEDS_THROW_FOR_STACK,\n/* harmony export */   \"getErrorWithStack\": () => /* binding */ getErrorWithStack,\n/* harmony export */   \"prettyStack\": () => /* binding */ prettyStack,\n/* harmony export */   \"deprecated\": () => /* binding */ deprecated\n/* harmony export */ });\n// By default, debug will be true only if platform is a web platform and its page is served from localhost.\r\n// When debug = true, error's stacks will contain asyncronic long stacks.\r\nvar debug = typeof location !== 'undefined' &&\r\n        // By default, use debug mode if served from localhost.\r\n        /^(http|https):\\/\\/(localhost|127\\.0\\.0\\.1)/.test(location.href);\r\n\r\nfunction setDebug(value, filter) {\r\n    debug = value;\r\n    libraryFilter = filter;\r\n}\r\n\r\nvar libraryFilter = () => true;\r\n\r\nconst NEEDS_THROW_FOR_STACK = !new Error(\"\").stack;\r\n\r\nfunction getErrorWithStack() {\r\n    \"use strict\";\r\n    if (NEEDS_THROW_FOR_STACK) try {\r\n        // Doing something naughty in strict mode here to trigger a specific error\r\n        // that can be explicitely ignored in debugger's exception settings.\r\n        // If we'd just throw new Error() here, IE's debugger's exception settings\r\n        // will just consider it as \"exception thrown by javascript code\" which is\r\n        // something you wouldn't want it to ignore.\r\n        getErrorWithStack.arguments;\r\n        throw new Error(); // Fallback if above line don't throw.\r\n    } catch(e) {\r\n        return e;\r\n    }\r\n    return new Error();\r\n}\r\n\r\nfunction prettyStack(exception, numIgnoredFrames) {\r\n    var stack = exception.stack;\r\n    if (!stack) return \"\";\r\n    numIgnoredFrames = (numIgnoredFrames || 0);\r\n    if (stack.indexOf(exception.name) === 0)\r\n        numIgnoredFrames += (exception.name + exception.message).split('\\n').length;\r\n    return stack.split('\\n')\r\n        .slice(numIgnoredFrames)\r\n        .filter(libraryFilter)\r\n        .map(frame => \"\\n\" + frame)\r\n        .join('');\r\n}\r\n\r\n// TODO: Replace this in favor of a decorator instead.\r\nfunction deprecated (what, fn) {\r\n    return function () {\r\n        console.warn(`${what} is deprecated. See http://dexie.org/docs/Deprecations. ${prettyStack(getErrorWithStack(), 1)}`);\r\n        return fn.apply(this, arguments);\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack:///./context-zone/microTaskZone/helpers/debug.js?");

/***/ }),

/***/ "./context-zone/microTaskZone/helpers/dexie.js":
/*!*****************************************************!*\
  !*** ./context-zone/microTaskZone/helpers/dexie.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"LONG_STACKS_CLIP_LIMIT\": () => /* binding */ LONG_STACKS_CLIP_LIMIT,\n/* harmony export */   \"MAX_LONG_STACKS\": () => /* binding */ MAX_LONG_STACKS,\n/* harmony export */   \"ZONE_ECHO_LIMIT\": () => /* binding */ ZONE_ECHO_LIMIT,\n/* harmony export */   \"resolvedNativePromise\": () => /* binding */ resolvedNativePromise,\n/* harmony export */   \"nativePromiseProto\": () => /* binding */ nativePromiseProto,\n/* harmony export */   \"resolvedGlobalPromise\": () => /* binding */ resolvedGlobalPromise,\n/* harmony export */   \"nativePromiseThen\": () => /* binding */ nativePromiseThen,\n/* harmony export */   \"NativePromise\": () => /* binding */ NativePromise,\n/* harmony export */   \"patchGlobalPromise\": () => /* binding */ patchGlobalPromise,\n/* harmony export */   \"microtickQueue\": () => /* binding */ microtickQueue,\n/* harmony export */   \"numScheduledCalls\": () => /* binding */ numScheduledCalls,\n/* harmony export */   \"tickFinalizers\": () => /* binding */ tickFinalizers,\n/* harmony export */   \"default\": () => /* binding */ DexiePromise,\n/* harmony export */   \"beginMicroTickScope\": () => /* binding */ beginMicroTickScope,\n/* harmony export */   \"endMicroTickScope\": () => /* binding */ endMicroTickScope\n/* harmony export */ });\n/* harmony import */ var _functions_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../functions/utils.js */ \"./context-zone/microTaskZone/functions/utils.js\");\n/* harmony import */ var _functions_chaining_functions_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../functions/chaining-functions.js */ \"./context-zone/microTaskZone/functions/chaining-functions.js\");\n/* harmony import */ var _debug_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./debug.js */ \"./context-zone/microTaskZone/helpers/debug.js\");\n/* harmony import */ var _errors_errors_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../errors/errors.js */ \"./context-zone/microTaskZone/errors/errors.js\");\n/* harmony import */ var _psd_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./psd.js */ \"./context-zone/microTaskZone/helpers/psd.js\");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n//\r\n// Promise and Zone (PSD) for Dexie library\r\n//\r\n// I started out writing this Promise class by copying promise-light (https://github.com/taylorhakes/promise-light) by\r\n// https://github.com/taylorhakes - an A+ and ECMASCRIPT 6 compliant Promise implementation.\r\n//\r\n// In previous versions this was fixed by not calling setTimeout when knowing that the resolve() or reject() came from another\r\n// tick. In Dexie v1.4.0, I\"ve rewritten the Promise class entirely. Just some fragments of promise-light is left. I use\r\n// another strategy now that simplifies everything a lot: to always execute callbacks in a new micro-task, but have an own micro-task\r\n// engine that is indexedDB compliant across all browsers.\r\n// Promise class has also been optimized a lot with inspiration from bluebird - to avoid closures as much as possible.\r\n// Also with inspiration from bluebird, asyncronic stacks in debug mode.\r\n//\r\n// Specific non-standard features of this Promise class:\r\n// * Custom zone support (a.k.a. PSD) with ability to keep zones also when using native promises as well as\r\n//   native async / await.\r\n// * Promise.follow() method built upon the custom zone engine, that allows user to track all promises created from current stack frame\r\n//   and below + all promises that those promises creates or awaits.\r\n// * Detect any unhandled promise in a PSD-scope (PSD.onunhandled).\r\n//\r\n// David Fahlander, https://github.com/dfahlander\r\n//\r\n// Just a pointer that only this module knows about.\r\n// Used in Promise constructor to emulate a private constructor.\r\nvar INTERNAL = {};\r\n// Async stacks (long stacks) must not grow infinitely.\r\nconst\r\n  LONG_STACKS_CLIP_LIMIT = 100,\r\n  // When calling error.stack or promise.stack, limit the number of asyncronic stacks to print out.\r\n  MAX_LONG_STACKS = 20,\r\n  ZONE_ECHO_LIMIT = 100,\r\n  [resolvedNativePromise, nativePromiseProto, resolvedGlobalPromise] = typeof Promise === \"undefined\" ?\r\n    [] :\r\n    (() => {\r\n      let globalP = Promise.resolve();\r\n      // if (typeof crypto === \"undefined\" || !crypto.subtle)\r\n      //    return [globalP, globalP.__proto__, globalP];\r\n      // Generate a native promise (as window.Promise may have been patched)\r\n      const nativeP = new Function(`const F = async () => {}, p = F();\r\n            return p;`)(); // alternative to crypto.subtle.digest(\"SHA-512\", new Uint8Array([0]));\r\n      return [\r\n        nativeP,\r\n        nativeP.__proto__,\r\n        globalP\r\n      ];\r\n    })();\r\n\r\nconst nativePromiseThen = nativePromiseProto && nativePromiseProto.then;\r\nconst nt = nativePromiseProto && nativePromiseProto.then;\r\nnativePromiseProto.then = function (onFulfilled, onRejected) {\r\n  return nt.call(this, onFulfilled, onRejected);\r\n};\r\n\r\nconst NativePromise = resolvedNativePromise && resolvedNativePromise.constructor;\r\nconst patchGlobalPromise = !!resolvedGlobalPromise;\r\nvar stack_being_generated = false;\r\n\r\n/* The default function used only for the very first promise in a promise chain.\r\n   As soon as then promise is resolved or rejected, all next tasks will be executed in micro ticks\r\n   emulated in this module. For indexedDB compatibility, this means that every method needs to\r\n   execute at least one promise before doing an indexedDB operation. Dexie will always call\r\n   db.ready().then() for every operation to make sure the indexedDB event is started in an\r\n   indexedDB-compatible emulated micro task loop.\r\n*/\r\nconst schedulePhysicalTick = resolvedGlobalPromise ?\r\n  () => { resolvedGlobalPromise.then(physicalTick); }\r\n  :\r\n  _functions_utils_js__WEBPACK_IMPORTED_MODULE_0__._global.setImmediate ?\r\n    // setImmediate supported. Those modern platforms also supports Function.bind().\r\n    setImmediate.bind(null, physicalTick) :\r\n    _functions_utils_js__WEBPACK_IMPORTED_MODULE_0__._global.MutationObserver ?\r\n      // MutationObserver supported\r\n      () => {\r\n        var hiddenDiv = document.createElement(\"div\");\r\n        (new MutationObserver(() => {\r\n          physicalTick();\r\n          hiddenDiv = null;\r\n        })).observe(hiddenDiv, { attributes: true });\r\n        hiddenDiv.setAttribute(\"i\", \"1\");\r\n      } :\r\n      // No support for setImmediate or MutationObserver. No worry, setTimeout is only called\r\n      // once time. Every tick that follows will be our emulated micro tick.\r\n      // Could have uses setTimeout.bind(null, 0, physicalTick) if it wasnt for that FF13 and below has a bug \r\n      () => { setTimeout(physicalTick, 0); };\r\n\r\n// Promise.schedulerで設定可能。\r\n// 未知のものをexportすると危険なので、exportしないでください。\r\n// コードは、コールバック内でキャッチを試みない限り、コールバックを呼び出します。\r\n// This function can be retrieved through getter of Promise.scheduler though,\r\n// この関数はPromise.schedulerのゲッターから取得できますが、ユーザはPromise.scheduler = myFuncThatThrowsExceptionをしてはいけません。\r\nconst asap = function (callback, args) {\r\n  microtickQueue.push([callback, args]);\r\n  if (needsNewPhysicalTick) {\r\n    schedulePhysicalTick();\r\n    needsNewPhysicalTick = false;\r\n  }\r\n};\r\nlet isOutsideMicroTick = true,\r\n  needsNewPhysicalTick = true,\r\n  unhandledErrors = [],\r\n  rejectingErrors = [],\r\n  currentFulfiller = null,\r\n  rejectionMapper = _functions_chaining_functions_js__WEBPACK_IMPORTED_MODULE_1__.mirror; // Remove in next major when removing error mapping of DOMErrors and DOMExceptions\r\n\r\nlet microtickQueue = []; // このtickまたは次のphysicalTickを呼び出すためのコールバック。\r\nlet numScheduledCalls = 0; // このphysicalTickに残されたリスナーコールの数。Number of listener-calls left to do in this physical tick.\r\nlet tickFinalizers = []; // Finalizers to call when there are no more async calls scheduled within current physical tick.\r\n\r\n\r\nfunction DexiePromise(fn) {\r\n  // console.log(\"デキシープロミス\");\r\n  if (typeof this !== \"object\")\r\n    throw new TypeError(\"Promises must be constructed via new\");\r\n  this._listeners = [];\r\n  this.onuncatched = _functions_chaining_functions_js__WEBPACK_IMPORTED_MODULE_1__.nop; // 次のメジャーでは非推奨。必要ありません。グローバルエラーハンドラを使った方が良い。\r\n\r\n  // ライブラリは、resolve()やreject()を実行するためにプロミスを作成した後に `promise._lib = true;` を設定することができます。\r\n  // A+に準拠するためには、ライブラリが resolve() や reject() を呼び出したときに、スタックにライブラリコードだけが含まれていることを保証できる場合に限り、 `_lib=true` を設定しなければなりません。\r\n  // RULE OF THUMB: グローバルスコープ(イベントハンドラやタイマーなど)から直接resolve/rejectを明示的に行うプロミスに対してのみ、_lib = true を設定してください。\r\n  this._lib = false;\r\n  // Current async scope\r\n  const psd = (this._PSD = _psd_js__WEBPACK_IMPORTED_MODULE_4__.PSD);\r\n\r\n  // if (debug) {\r\n  //   this._stackHolder = getErrorWithStack();\r\n  //   this._prev = null;\r\n  //   this._numPrev = 0; // Number of previous promises (for long stacks)\r\n  // }\r\n  if (typeof fn !== \"function\") { // fnが関数でないとき、エラーハンドル\r\n    if (fn !== INTERNAL)\r\n      throw new TypeError(\"Not a function\");\r\n    // Private constructor (INTERNAL, state, value).\r\n    // Used internally by Promise.resolve() and Promise.reject().\r\n    this._state = arguments[1];\r\n    this._value = arguments[2];\r\n    if (this._state === false)\r\n      handleRejection(this, this._value); // Map error, set stack and addPossiblyUnhandledError().\r\n    return;\r\n  }\r\n\r\n  this._state = null; // null (=pending), false (=rejected) or true (=resolved)\r\n  this._value = null; // error or result\r\n  ++psd.ref; // 現在のスコープのカウント\r\n  executePromiseTask(this, fn);\r\n}\r\n\r\n/**\r\n* 誤った動作をする可能性のあるresolver関数を使用して、onFulfilled と onRejected が一度だけ呼び出されるようにします。\r\n* 非同期性を保証しません。\r\n*/\r\nfunction executePromiseTask(promise, fn) {\r\n  // Promise Resolution Procedure:\r\n  // https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure\r\n  try {\r\n    const resolve = value => {\r\n      if (promise._state !== null)\r\n        return; // Already settled\r\n      if (value === promise)\r\n        throw new TypeError(\"A promise cannot be resolved with itself.\");\r\n      const shouldExecuteTick = promise._lib && beginMicroTickScope();\r\n      if (value && typeof value.then === \"function\") { // resolve(Promise)\r\n        executePromiseTask(promise, (resolve, reject) => {\r\n          value instanceof DexiePromise ? // valueがDexiePromiseのインスタンスか\r\n            value._then(resolve, reject) :\r\n            value.then(resolve, reject);\r\n        });\r\n      } else {\r\n        promise._state = true;\r\n        promise._value = value;\r\n        propagateAllListeners(promise);\r\n      }\r\n      if (shouldExecuteTick) { // don't called\r\n        endMicroTickScope();\r\n      }\r\n    };\r\n    const reject = handleRejection.bind(null, promise);\r\n\r\n    fn(resolve, reject); // If Function.bind is not supported. Exception is handled in catch below\r\n  } catch (ex) {\r\n    handleRejection(promise, ex);\r\n  }\r\n}\r\n\r\nfunction propagateAllListeners(promise) {\r\n  // _listeners内全てのListenerを伝播\r\n  const listeners = promise._listeners;\r\n  promise._listeners = [];\r\n  for (let i = 0, len = listeners.length; i < len; ++i) {\r\n    propagateToListener(promise, listeners[i]);\r\n  }\r\n\r\n  const psd = promise._PSD;\r\n  --psd.ref || psd.finalize(); // if psd.ref reaches zero, call psd.finalize();\r\n  if (numScheduledCalls === 0) {\r\n    // numScheduledCallsが0の場合、スタックにスケジューリングされたコールバックにないことを意味し、このrejection or successを聞いているdeferredsがないことを意味します。\r\n    // 私たちのスタックには、このコードが終了した後に新しい呼び出しを生成するようなアプリケーションコードが含まれている可能性があるので、ここでファイナライザを呼び出すことはできません。\r\n    ++numScheduledCalls;\r\n    asap(() => {\r\n      if (--numScheduledCalls === 0)\r\n        finalizePhysicalTick(); // Will detect unhandled errors\r\n    }, []);\r\n  }\r\n}\r\n\r\nfunction propagateToListener(promise, listener) {\r\n  if (promise._state === null) {\r\n    promise._listeners.push(listener);\r\n    return;\r\n  }\r\n\r\n  var callback = promise._state ? listener.onFulfilled : listener.onRejected;\r\n  if (callback === null) {\r\n    // This Listener doesnt have a listener for the event being triggered (onFulfilled or onReject) so lets forward the event to any eventual listeners on the Promise instance returned by then() or catch()\r\n    return (promise._state ? listener.resolve : listener.reject)(promise._value);\r\n  }\r\n  ++listener.psd.ref;\r\n  ++numScheduledCalls;\r\n  asap(callListener, [callback, promise, listener]);\r\n}\r\n\r\nfunction callListener(cb, promise, listener) {\r\n  try {\r\n    // スタティック変数 currentFulfiller をフルフィルされているPromiseに設定し、Promiseのチェーンを接続するようにします (ロングスタックのサポートのため)\r\n    currentFulfiller = promise;\r\n\r\n    // Call callback and resolve our listener with it\"s return value.\r\n    let ret, value = promise._value;\r\n\r\n    if (promise._state) {\r\n      // cb is onResolved\r\n      ret = cb(value);\r\n    } else {\r\n      // cb is onRejected\r\n      if (rejectingErrors.length)\r\n        rejectingErrors = [];\r\n      ret = cb(value);\r\n      if (rejectingErrors.indexOf(value) === -1)\r\n        markErrorAsHandled(promise); // Callback didnt do Promise.reject(err) nor reject(err) onto another promise.\r\n    }\r\n    listener.resolve(ret);\r\n  } catch (e) {\r\n    // Exception thrown in callback. Reject our listener.\r\n    listener.reject(e);\r\n  } finally {\r\n    // Restore env and currentFulfiller.\r\n    currentFulfiller = null;\r\n    if (--numScheduledCalls === 0)\r\n      finalizePhysicalTick();\r\n    --listener.psd.ref || listener.psd.finalize();\r\n  }\r\n}\r\n\r\n// Promise.prototype.thenに載せるプロパティ記述子を用意します。\r\nconst thenProp = {\r\n  // DexiePromise.thenの正体\r\n  get: function () {\r\n    const psd = _psd_js__WEBPACK_IMPORTED_MODULE_4__.PSD, microTaskId = _psd_js__WEBPACK_IMPORTED_MODULE_4__.totalEchoes;\r\n\r\n    function then(onFulfilled, onRejected) {\r\n      const possibleAwait = !psd.global && (psd !== _psd_js__WEBPACK_IMPORTED_MODULE_4__.PSD || microTaskId !== _psd_js__WEBPACK_IMPORTED_MODULE_4__.totalEchoes);\r\n      if (possibleAwait) {\r\n        // async/await使用時\r\n        (0,_psd_js__WEBPACK_IMPORTED_MODULE_4__.decrementExpectedAwaits)();\r\n      }\r\n      const rv = new DexiePromise((resolve, reject) => {\r\n        propagateToListener(this, new Listener( // このthisはthenが実行されたときのpromise\r\n          (0,_psd_js__WEBPACK_IMPORTED_MODULE_4__.nativeAwaitCompatibleWrap)(onFulfilled, psd, possibleAwait),\r\n          (0,_psd_js__WEBPACK_IMPORTED_MODULE_4__.nativeAwaitCompatibleWrap)(onRejected, psd, possibleAwait),\r\n          resolve,\r\n          reject,\r\n          psd));\r\n      });\r\n      // debug && linkToPreviousPromise(rv, this);\r\n      return rv;\r\n    }\r\n\r\n    then.prototype = INTERNAL; // For idempotense, see setter below.\r\n    return then;\r\n  },\r\n  // Be idempotent and allow another framework (such as zone.js or another instance of a Dexie.Promise module) to replace Promise.prototype.then\r\n  // and when that framework wants to restore the original property, we must identify that and restore the original property descriptor.\r\n  set: function (value) {\r\n    (0,_functions_utils_js__WEBPACK_IMPORTED_MODULE_0__.setProp)(this, \"then\", value && value.prototype === INTERNAL ?\r\n      thenProp : // Restore to original property descriptor.\r\n      {\r\n        get: function () {\r\n          return value; // Getter returning provided value (behaves like value is just changed)\r\n        },\r\n        set: thenProp.set // Keep a setter that is prepared to restore original.\r\n      }\r\n    );\r\n  }\r\n};\r\n\r\n(0,_functions_utils_js__WEBPACK_IMPORTED_MODULE_0__.props)(DexiePromise.prototype, {\r\n  then: thenProp,\r\n  _then: function (onFulfilled, onRejected) {\r\n    // 結果のプロミスを作成する必要のない then() の少し小さなバージョン。\r\n    propagateToListener(this, new Listener(null, null, onFulfilled, onRejected, _psd_js__WEBPACK_IMPORTED_MODULE_4__.PSD));\r\n  },\r\n\r\n  catch: function (onRejected) {\r\n    if (arguments.length === 1)\r\n      return this.then(null, onRejected);\r\n    // First argument is the Error type to catch\r\n    var type = arguments[0],\r\n      handler = arguments[1];\r\n    return typeof type === \"function\" ? this.then(null, err =>\r\n      // Catching errors by its constructor type (similar to java / c++ / c#)\r\n      // Sample: promise.catch(TypeError, function (e) { ... });\r\n      err instanceof type ? handler(err) : PromiseReject(err))\r\n      : this.then(null, err =>\r\n        // Catching errors by the error.name property. Makes sense for indexedDB where error type\r\n        // is always DOMError but where e.name tells the actual error type.\r\n        // Sample: promise.catch(\"ConstraintError\", function (e) { ... });\r\n        err && err.name === type ? handler(err) : PromiseReject(err));\r\n  },\r\n\r\n  finally: function (onFinally) {\r\n    return this.then(value => {\r\n      onFinally();\r\n      return value;\r\n    }, err => {\r\n      onFinally();\r\n      return PromiseReject(err);\r\n    });\r\n  },\r\n\r\n  stack: {\r\n    get: function () {\r\n      if (this._stack)\r\n        return this._stack;\r\n      try {\r\n        stack_being_generated = true;\r\n        var stacks = getStack(this, [], MAX_LONG_STACKS);\r\n        var stack = stacks.join(\"\\nFrom previous: \");\r\n        if (this._state !== null)\r\n          this._stack = stack; // Stack may be updated on reject.\r\n        return stack;\r\n      } finally {\r\n        stack_being_generated = false;\r\n      }\r\n    }\r\n  },\r\n\r\n  timeout: function (ms, msg) {\r\n    return ms < Infinity ?\r\n      new DexiePromise((resolve, reject) => {\r\n        var handle = setTimeout(() => reject(new _errors_errors_js__WEBPACK_IMPORTED_MODULE_3__.exceptions.Timeout(msg)), ms);\r\n        this.then(resolve, reject).finally(clearTimeout.bind(null, handle));\r\n      }) : this;\r\n  }\r\n});\r\nif (typeof Symbol !== \"undefined\" && Symbol.toStringTag) {\r\n  // called\r\n  (0,_functions_utils_js__WEBPACK_IMPORTED_MODULE_0__.setProp)(DexiePromise.prototype, Symbol.toStringTag, \"Dexie.Promise\");\r\n}\r\n// Now that Promise.prototype is defined, we have all it takes to set globalPSD.env.\r\n// Environment globals snapshotted on leaving global zone\r\nfunction Listener(onFulfilled, onRejected, resolve, reject, zone) {\r\n  this.onFulfilled = typeof onFulfilled === \"function\" ? onFulfilled : null;\r\n  this.onRejected = typeof onRejected === \"function\" ? onRejected : null;\r\n  this.resolve = resolve;\r\n  this.reject = reject;\r\n  this.psd = zone;\r\n}\r\n// Promise Static Properties\r\n(0,_functions_utils_js__WEBPACK_IMPORTED_MODULE_0__.props)(DexiePromise, {\r\n  all: function () {\r\n    var values = _functions_utils_js__WEBPACK_IMPORTED_MODULE_0__.getArrayOf.apply(null, arguments) // Supports iterables, implicit arguments and array-like.\r\n      .map(_psd_js__WEBPACK_IMPORTED_MODULE_4__.onPossibleParallellAsync); // Handle parallell async/awaits\r\n    return new DexiePromise(function (resolve, reject) {\r\n      if (values.length === 0)\r\n        resolve([]);\r\n      var remaining = values.length;\r\n      values.forEach((a, i) => DexiePromise.resolve(a).then(x => {\r\n        values[i] = x;\r\n        if (!--remaining)\r\n          resolve(values);\r\n      }, reject));\r\n    });\r\n  },\r\n\r\n  resolve: value => {\r\n    if (value instanceof DexiePromise)\r\n      return value;\r\n    if (value && typeof value.then === \"function\")\r\n      return new DexiePromise((resolve, reject) => {\r\n        value.then(resolve, reject);\r\n      });\r\n    var rv = new DexiePromise(INTERNAL, true, value);\r\n    linkToPreviousPromise(rv, currentFulfiller);\r\n    return rv;\r\n  },\r\n\r\n  reject: PromiseReject,\r\n\r\n  race: function () {\r\n    var values = _functions_utils_js__WEBPACK_IMPORTED_MODULE_0__.getArrayOf.apply(null, arguments).map(_psd_js__WEBPACK_IMPORTED_MODULE_4__.onPossibleParallellAsync);\r\n    return new DexiePromise((resolve, reject) => {\r\n      values.map(value => DexiePromise.resolve(value).then(resolve, reject));\r\n    });\r\n  },\r\n\r\n  allSettled() {\r\n    const possiblePromises = _functions_utils_js__WEBPACK_IMPORTED_MODULE_0__.getArrayOf.apply(null, arguments).map(_psd_js__WEBPACK_IMPORTED_MODULE_4__.onPossibleParallellAsync);\r\n    return new DexiePromise(resolve => {\r\n      if (possiblePromises.length === 0)\r\n        resolve([]);\r\n      let remaining = possiblePromises.length;\r\n      const results = new Array(remaining);\r\n      possiblePromises.forEach((p, i) => DexiePromise.resolve(p).then(\r\n        value => results[i] = { status: \"fulfilled\", value },\r\n        reason => results[i] = { status: \"rejected\", reason })\r\n        .then(() => --remaining || resolve(results)));\r\n    });\r\n  },\r\n\r\n  any() {\r\n    const possiblePromises = _functions_utils_js__WEBPACK_IMPORTED_MODULE_0__.getArrayOf.apply(null, arguments).map(_psd_js__WEBPACK_IMPORTED_MODULE_4__.onPossibleParallellAsync);\r\n    return new DexiePromise((resolve, reject) => {\r\n      if (possiblePromises.length === 0)\r\n        reject(new AggregateError([]));\r\n      let remaining = possiblePromises.length;\r\n      const failures = new Array(remaining);\r\n      possiblePromises.forEach((p, i) => DexiePromise.resolve(p).then(\r\n        value => resolve(value),\r\n        failure => {\r\n          failures[i] = failure;\r\n          if (!--remaining)\r\n            reject(new AggregateError(failures));\r\n        }));\r\n    });\r\n  },\r\n\r\n  PSD: {\r\n    get: () => _psd_js__WEBPACK_IMPORTED_MODULE_4__.PSD,\r\n    set: value => _psd_js__WEBPACK_IMPORTED_MODULE_4__.PSD = value\r\n  },\r\n\r\n  //totalEchoes: {get: ()=>totalEchoes},\r\n  //task: {get: ()=>task},\r\n  newPSD: _psd_js__WEBPACK_IMPORTED_MODULE_4__.newScope,\r\n\r\n  usePSD: _psd_js__WEBPACK_IMPORTED_MODULE_4__.usePSD,\r\n\r\n  scheduler: {\r\n    get: () => asap,\r\n    set: value => { asap = value; }\r\n  },\r\n\r\n  rejectionMapper: {\r\n    get: () => rejectionMapper,\r\n    set: value => { rejectionMapper = value; } // Map reject failures\r\n  },\r\n\r\n  follow: (fn, zoneProps) => {\r\n    return new DexiePromise((resolve, reject) => {\r\n      return (0,_psd_js__WEBPACK_IMPORTED_MODULE_4__.newScope)((resolve, reject) => {\r\n        var psd = _psd_js__WEBPACK_IMPORTED_MODULE_4__.PSD;\r\n        psd.unhandleds = []; // For unhandled standard- or 3rd party Promises. Checked at psd.finalize()\r\n        psd.onunhandled = reject; // Triggered directly on unhandled promises of this library.\r\n        psd.finalize = (0,_functions_chaining_functions_js__WEBPACK_IMPORTED_MODULE_1__.callBoth)(function () {\r\n          // Unhandled standard or 3rd part promises are put in PSD.unhandleds and\r\n          // examined upon scope completion while unhandled rejections in this Promise\r\n          // will trigger directly through psd.onunhandled\r\n          run_at_end_of_this_or_next_physical_tick(() => {\r\n            this.unhandleds.length === 0 ? resolve() : reject(this.unhandleds[0]);\r\n          });\r\n        }, psd.finalize);\r\n        fn();\r\n      }, zoneProps, resolve, reject);\r\n    });\r\n  }\r\n});\r\n\r\nfunction handleRejection(promise, reason) {\r\n  rejectingErrors.push(reason);\r\n  if (promise._state !== null)\r\n    return;\r\n  var shouldExecuteTick = promise._lib && beginMicroTickScope();\r\n  reason = rejectionMapper(reason);\r\n  promise._state = false;\r\n  promise._value = reason;\r\n  _debug_js__WEBPACK_IMPORTED_MODULE_2__.debug && reason !== null && typeof reason === \"object\" && !reason._promise && (0,_functions_utils_js__WEBPACK_IMPORTED_MODULE_0__.tryCatch)(() => {\r\n    var origProp = (0,_functions_utils_js__WEBPACK_IMPORTED_MODULE_0__.getPropertyDescriptor)(reason, \"stack\");\r\n    reason._promise = promise;\r\n    (0,_functions_utils_js__WEBPACK_IMPORTED_MODULE_0__.setProp)(reason, \"stack\", {\r\n      get: () => stack_being_generated ?\r\n        origProp && (origProp.get ?\r\n          origProp.get.apply(reason) :\r\n          origProp.value) :\r\n        promise.stack\r\n    });\r\n  });\r\n  // Add the failure to a list of possibly uncaught errors\r\n  addPossiblyUnhandledError(promise);\r\n  propagateAllListeners(promise);\r\n  if (shouldExecuteTick)\r\n    endMicroTickScope();\r\n}\r\n\r\nfunction getStack(promise, stacks, limit) {\r\n  if (stacks.length === limit)\r\n    return stacks;\r\n  var stack = \"\";\r\n  if (promise._state === false) {\r\n    var failure = promise._value,\r\n      errorName,\r\n      message;\r\n\r\n    if (failure != null) {\r\n      errorName = failure.name || \"Error\";\r\n      message = failure.message || failure;\r\n      stack = (0,_debug_js__WEBPACK_IMPORTED_MODULE_2__.prettyStack)(failure, 0);\r\n    } else {\r\n      errorName = failure; // If error is undefined or null, show that.\r\n      message = \"\";\r\n    }\r\n    stacks.push(errorName + (message ? \": \" + message : \"\") + stack);\r\n  }\r\n  if (_debug_js__WEBPACK_IMPORTED_MODULE_2__.debug) {\r\n    stack = (0,_debug_js__WEBPACK_IMPORTED_MODULE_2__.prettyStack)(promise._stackHolder, 2);\r\n    if (stack && stacks.indexOf(stack) === -1)\r\n      stacks.push(stack);\r\n    if (promise._prev)\r\n      getStack(promise._prev, stacks, limit);\r\n  }\r\n  return stacks;\r\n}\r\n\r\nfunction linkToPreviousPromise(promise, prev) {\r\n  // Support long stacks by linking to previous completed promise.\r\n  var numPrev = prev ? prev._numPrev + 1 : 0;\r\n  if (numPrev < LONG_STACKS_CLIP_LIMIT) { // Prohibit infinite Promise loops to get an infinite long memory consuming \"tail\".\r\n    promise._prev = prev;\r\n    promise._numPrev = numPrev;\r\n  }\r\n}\r\n\r\n/* The callback to schedule with setImmediate() or setTimeout().\r\n   It runs a virtual microtick and executes any callback registered in microtickQueue.\r\n */\r\nfunction physicalTick() {\r\n  beginMicroTickScope() && endMicroTickScope();\r\n}\r\n\r\nfunction beginMicroTickScope() {\r\n  const wasRootExec = isOutsideMicroTick;\r\n  isOutsideMicroTick = false;\r\n  needsNewPhysicalTick = false;\r\n  return wasRootExec;\r\n}\r\n/* Executes micro-ticks without doing try..catch.\r\n   This can be possible because we only use this internally and\r\n   the registered functions are exception-safe (they do try..catch\r\n   internally before calling any external method). If registering\r\n   functions in the microtickQueue that are not exception-safe, this\r\n   would destroy the framework and make it instable. So we don\"t export\r\n   our asap method.\r\n*/\r\nfunction endMicroTickScope() {\r\n  let callbacks, i, l;\r\n  do {\r\n    // microtickQueueに格納された全てのコールバックを実行。\r\n    while (microtickQueue.length > 0) {\r\n      callbacks = microtickQueue;\r\n      microtickQueue = [];\r\n      l = callbacks.length;\r\n      for (i = 0; i < l; ++i) {\r\n        var item = callbacks[i];\r\n        item[0].apply(null, item[1]);\r\n      }\r\n    }\r\n  } while (microtickQueue.length > 0);\r\n  isOutsideMicroTick = true;\r\n  needsNewPhysicalTick = true;\r\n}\r\n\r\nfunction finalizePhysicalTick() {\r\n  var unhandledErrs = unhandledErrors;\r\n  unhandledErrors = [];\r\n  unhandledErrs.forEach(p => {\r\n    p._PSD.onunhandled.call(null, p._value, p);\r\n  });\r\n  var finalizers = tickFinalizers.slice(0); // Clone first because finalizer may remove itself from list.\r\n  var i = finalizers.length;\r\n  while (i)\r\n    finalizers[--i]();\r\n}\r\n\r\nfunction run_at_end_of_this_or_next_physical_tick(fn) {\r\n  function finalizer() {\r\n    fn();\r\n    tickFinalizers.splice(tickFinalizers.indexOf(finalizer), 1);\r\n  }\r\n  tickFinalizers.push(finalizer);\r\n  ++numScheduledCalls;\r\n  asap(() => {\r\n    if (--numScheduledCalls === 0)\r\n      finalizePhysicalTick();\r\n  }, []);\r\n}\r\n\r\nfunction addPossiblyUnhandledError(promise) {\r\n  // Only add to unhandledErrors if not already there. The first one to add to this list\r\n  // will be upon the first rejection so that the root cause (first promise in the\r\n  // rejection chain) is the one listed.\r\n  if (!unhandledErrors.some(p => p._value === promise._value))\r\n    unhandledErrors.push(promise);\r\n}\r\n\r\nfunction markErrorAsHandled(promise) {\r\n  // Called when a reject handled is actually being called.\r\n  // Search in unhandledErrors for any promise whos _value is this promise_value (list\r\n  // contains only rejected promises, and only one item per error)\r\n  var i = unhandledErrors.length;\r\n  while (i)\r\n    if (unhandledErrors[--i]._value === promise._value) {\r\n      // Found a promise that failed with this same error object pointer,\r\n      // Remove that since there is a listener that actually takes care of it.\r\n      unhandledErrors.splice(i, 1);\r\n      return;\r\n    }\r\n}\r\n\r\nfunction PromiseReject(reason) {\r\n  return new DexiePromise(INTERNAL, false, reason);\r\n}\r\n\n\n//# sourceURL=webpack:///./context-zone/microTaskZone/helpers/dexie.js?");

/***/ }),

/***/ "./context-zone/microTaskZone/helpers/psd.js":
/*!***************************************************!*\
  !*** ./context-zone/microTaskZone/helpers/psd.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"microTaskScope\": () => /* binding */ microTaskScope,\n/* harmony export */   \"globalPSD\": () => /* binding */ globalPSD,\n/* harmony export */   \"PSD\": () => /* binding */ PSD,\n/* harmony export */   \"totalEchoes\": () => /* binding */ totalEchoes,\n/* harmony export */   \"newScope\": () => /* binding */ newScope,\n/* harmony export */   \"usePSD\": () => /* binding */ usePSD,\n/* harmony export */   \"incrementExpectedAwaits\": () => /* binding */ incrementExpectedAwaits,\n/* harmony export */   \"decrementExpectedAwaits\": () => /* binding */ decrementExpectedAwaits,\n/* harmony export */   \"onPossibleParallellAsync\": () => /* binding */ onPossibleParallellAsync,\n/* harmony export */   \"snapShot\": () => /* binding */ snapShot,\n/* harmony export */   \"nativeAwaitCompatibleWrap\": () => /* binding */ nativeAwaitCompatibleWrap,\n/* harmony export */   \"rejection\": () => /* binding */ rejection\n/* harmony export */ });\n/* harmony import */ var _functions_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../functions/utils.js */ \"./context-zone/microTaskZone/functions/utils.js\");\n/* harmony import */ var _debug_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./debug.js */ \"./context-zone/microTaskZone/helpers/debug.js\");\n/* harmony import */ var _dexie_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./dexie.js */ \"./context-zone/microTaskZone/helpers/dexie.js\");\n\r\n\r\n\r\n\r\n\r\nconst microTaskScope = (callback, props) => {\r\n  let returnValue;\r\n  try {\r\n    incrementExpectedAwaits();\r\n\r\n    newScope(() => {\r\n      returnValue = callback.call();\r\n    }, props);\r\n  } finally {\r\n    if (returnValue && typeof returnValue.then === \"function\") {\r\n      returnValue.then(() => decrementExpectedAwaits());\r\n    } else {\r\n      decrementExpectedAwaits();\r\n    }\r\n  }\r\n}\r\n\r\nlet globalPSD = {\r\n  id: \"global\",\r\n  global: true,\r\n  ref: 0,\r\n  unhandleds: [],\r\n  onunhandled: globalError,\r\n  pgp: false,\r\n  env: {},\r\n  finalize: function () {\r\n    this.unhandleds.forEach(uh => {\r\n      try {\r\n        globalError(uh[0], uh[1]);\r\n      } catch (e) { }\r\n    });\r\n  }\r\n};\r\n\r\nlet PSD = globalPSD;\r\nglobalPSD.env = snapShot();\r\n\r\n\r\n// native awaitのサポートに使用される変数。variables used for native await support\r\nconst task = { awaits: 0, echoes: 0, id: 0 }; // ゾーンエコー使用時の進行中のmacro task。\r\n// echoes !== 0: we are in zone-echoing mode!\r\nlet taskCounter = 0; // macro taskのIDカウンタ\r\nlet zoneStack = []; // 非同期に復元する左ゾーンのスタック。\r\nlet zoneEchoes = 0; // zoneEchoesは、native await式間のゾーンを持続させるためには必須です。\r\nlet totalEchoes = 0; // マイクロタスクのIDカウンタ。Promise.prototype.thenでネイティブが待機している可能性を検出するために使用されます。\r\n\r\nlet zone_id_counter = 0;\r\nfunction newScope(fn, props, a1, a2) {\r\n  let parent = PSD;\r\n  let psd = Object.create(parent);\r\n\r\n  psd.parent = parent;\r\n  psd.ref = 0;\r\n  psd.global = false;\r\n  psd.id = ++zone_id_counter;\r\n\r\n  // Promiseパッチの準備（usePSDで行います）。\r\n  let globalEnv = globalPSD.env;\r\n  psd.env = _dexie_js__WEBPACK_IMPORTED_MODULE_2__.patchGlobalPromise ? { // patchGlobalPromise = true\r\n    Promise: _dexie_js__WEBPACK_IMPORTED_MODULE_2__.default, // IDB+Promiseが活躍するChromeやEdgeでは、window.Promiseの変更は省略できるかもしれません。\r\n    PromiseProp: { value: _dexie_js__WEBPACK_IMPORTED_MODULE_2__.default, configurable: true, writable: true }, // definePropertyによるPromiseの定義に用いる。\r\n    all: _dexie_js__WEBPACK_IMPORTED_MODULE_2__.default.all,\r\n    race: _dexie_js__WEBPACK_IMPORTED_MODULE_2__.default.race,\r\n    allSettled: _dexie_js__WEBPACK_IMPORTED_MODULE_2__.default.allSettled,\r\n    any: _dexie_js__WEBPACK_IMPORTED_MODULE_2__.default.any,\r\n    resolve: _dexie_js__WEBPACK_IMPORTED_MODULE_2__.default.resolve,\r\n    reject: _dexie_js__WEBPACK_IMPORTED_MODULE_2__.default.reject,\r\n    nthen: getPatchedPromiseThen(globalEnv.nthen, psd), // native then\r\n    gthen: getPatchedPromiseThen(globalEnv.gthen, psd) // global then\r\n  } : {};\r\n\r\n  if (props) (0,_functions_utils_js__WEBPACK_IMPORTED_MODULE_0__.extend)(psd, props); // afterEnter, afterLeave Propsを設定。\r\n\r\n  // unhandledsとonunhandledは、ここでは特に設定する必要なし。\r\n  ++parent.ref;\r\n  psd.finalize = function () {\r\n    --this.parent.ref || this.parent.finalize();\r\n  }\r\n  const returnValue = usePSD(psd, fn, a1, a2);\r\n\r\n  if (psd.ref === 0) {\r\n    psd.finalize();\r\n  }\r\n  return returnValue;\r\n}\r\n\r\nfunction usePSD(psd, fn, a1, a2, a3) {\r\n  const outerScope = PSD;\r\n  try {\r\n    switchToZone(psd, true);\r\n\r\n    const rtn = fn(a1, a2, a3);\r\n    return rtn;\r\n  } finally {\r\n    switchToZone(outerScope, false);\r\n  }\r\n}\r\n\r\nfunction switchToZone(targetZone, isEnteringZone) {\r\n  let currentZone = PSD;\r\n  if (\r\n    // isEnteringZone ? zoneEchoesを1に : zoneEchoesを0に(既にzoneEchoes===0のとき、終了)\r\n    // isEnteringZone ===> decrementExpectedAwaits()が実行されtask.echoesが0になり終了\r\n    // !isEnteringZone ===> isEnteringZoneのときにzoneEchoesがインクリメントされず0となり終了\r\n    isEnteringZone ?\r\n      task.echoes && (!zoneEchoes++ || targetZone !== PSD) :\r\n      zoneEchoes && (!--zoneEchoes || targetZone !== PSD)\r\n  ) {\r\n    // ゾーンへの入退出も同様に非同期的に行い、現在のティックの間に開始されたタスクが呼び出されたときにゾーンに囲まれるようにします。\r\n    enqueueNativeMicroTask(isEnteringZone ? zoneEnterEcho.bind(null, targetZone) : zoneLeaveEcho);\r\n  } else {\r\n    console.log(\"zoneSwitch停止\");\r\n  }\r\n  if (targetZone === PSD) return;\r\n\r\n  function lifeCycleCallback(fn) {\r\n    if (typeof fn !== \"function\") { return; }\r\n    fn(currentZone, targetZone);\r\n  }\r\n  if (isEnteringZone) {\r\n    lifeCycleCallback(targetZone.beforeEnter);\r\n  } else {\r\n    lifeCycleCallback(currentZone.beforeLeave);\r\n  }\r\n\r\n  // console.error({ ...targetZone });\r\n  // if (Object.keys(targetZone).length) return;\r\n  PSD = targetZone; // 実際のゾーン切り替えはこの行で発生します。\r\n\r\n  // globalゾーンから離れる際に毎回スナップショットします。\r\n  if (currentZone === globalPSD) globalPSD.env = snapShot();\r\n\r\n  if (_dexie_js__WEBPACK_IMPORTED_MODULE_2__.patchGlobalPromise) {\r\n    // グローバルとネイティブのPromiseにパッチを当ててみましょう(同じかもしれませんし、違うかもしれません)。Let\"s patch the global and native Promises (may be same or may be different)\r\n    let GlobalPromise = globalPSD.env.Promise;\r\n    // envを切り替えます（PSDゾーンまたはグローバルゾーンのいずれかである可能性があります)。Switch environments (may be PSD-zone or the global zone. Both apply.)\r\n    let targetEnv = targetZone.env;\r\n\r\n    // ネイティブとグローバルのPromise用にPromise.prototype.thenを変更します(ポリフィル環境では異なりますが、両方にアクセスできます。)。\r\n    // パッチ適用されたメソッドのクロージャにtargetZoneが含まれているため、ゾーンの変更ごとに行う必要があります。\r\n    _dexie_js__WEBPACK_IMPORTED_MODULE_2__.nativePromiseProto.then = targetEnv.nthen;\r\n    GlobalPromise.prototype.then = targetEnv.gthen;\r\n\r\n    if (currentZone.global || targetZone.global) {\r\n      // グローバルゾーンからの離脱、またはグローバルゾーンへの進入。グローバルプロミスのパッチ/復元の時間です。\r\n\r\n      // このPromiseをwindow.Promiseに設定することで、遷移した非同期関数がFirefox、Safari、IE、そしてZonejsやangularでも動作するようにします。\r\n      Object.defineProperty(_functions_utils_js__WEBPACK_IMPORTED_MODULE_0__._global, \"Promise\", targetEnv.PromiseProp);\r\n\r\n      // Promise.all()などをサポートし、es6-promise をモジュールとして含めている場合にも indexedDB-safe で動作するようにした (global.Promise にアクセスしているのではなく、ローカルで参照している可能性があります)。\r\n      GlobalPromise.all = targetEnv.all;\r\n      GlobalPromise.race = targetEnv.race;\r\n      GlobalPromise.resolve = targetEnv.resolve;\r\n      GlobalPromise.reject = targetEnv.reject;\r\n      GlobalPromise.allSettled = targetEnv.allSettled;\r\n      GlobalPromise.any = targetEnv.any;\r\n    }\r\n  }\r\n\r\n  if (isEnteringZone) {\r\n    lifeCycleCallback(targetZone.afterEnter);\r\n  } else {\r\n    lifeCycleCallback(currentZone.afterLeave);\r\n  }\r\n}\r\n\r\nfunction enqueueNativeMicroTask(job) {\r\n  // 前提条件： nativePromiseThen !== undefined\r\n  // thenを実行することでresolvedNativePromiseが解決されたときに実行されるタスク(job)をスケジュールしている。\r\n  _dexie_js__WEBPACK_IMPORTED_MODULE_2__.nativePromiseThen.call(_dexie_js__WEBPACK_IMPORTED_MODULE_2__.resolvedNativePromise, job);\r\n}\r\n\r\nfunction zoneEnterEcho(targetZone) {\r\n  console.log(\"zoneエンター\");\r\n  ++totalEchoes;\r\n\r\n  if (!task.echoes || --task.echoes === 0) { // task.echoesが0, または1のとき(task.echoesが>0ときtask.echoesをデクリメント)\r\n    task.echoes = task.id = 0; // Cancel zone echoing.\r\n  }\r\n\r\n  zoneStack.push(PSD); // zoneを復元するため現在のPSDをzoneStackに格納\r\n  switchToZone(targetZone, true);\r\n}\r\n\r\nfunction zoneLeaveEcho() {\r\n  console.log(\"zoneリーブ\");\r\n  var preZone = zoneStack[zoneStack.length - 1]; // zoneEnterEcho()で格納しておいたzoneを取り出し復元\r\n  zoneStack.pop();\r\n\r\n  switchToZone(preZone, false);\r\n}\r\n\r\n\r\n/**\r\n * scopeFuncがNativePromiseを返した場合に呼び出す関数。Promise.all() の引数に含まれる各 NativePromise についても同様です。\r\n */\r\nfunction incrementExpectedAwaits() {\r\n  if (!task.id) task.id = ++taskCounter;\r\n  ++task.awaits;\r\n  task.echoes += _dexie_js__WEBPACK_IMPORTED_MODULE_2__.ZONE_ECHO_LIMIT;\r\n  return task.id;\r\n}\r\n\r\n// Function to call when \"then\" calls back on a native promise where onAwaitExpected() had been called.\r\n// Also call this when a native await calls then method on a promise. In that case, don\"t supply\r\n// sourceTaskId because we already know it refers to current task.\r\nfunction decrementExpectedAwaits(sourceTaskId) {\r\n  if (!task.awaits || (sourceTaskId && sourceTaskId !== task.id)) return;\r\n  if (--task.awaits === 0) task.id = 0;\r\n  task.echoes = task.awaits * _dexie_js__WEBPACK_IMPORTED_MODULE_2__.ZONE_ECHO_LIMIT; // Will reset echoes to 0 if awaits is 0.\r\n}\r\n\r\n\r\n// Call from Promise.all() and Promise.race()\r\nfunction onPossibleParallellAsync(possiblePromise) {\r\n  if (task.echoes && possiblePromise && possiblePromise.constructor === _dexie_js__WEBPACK_IMPORTED_MODULE_2__.NativePromise) {\r\n    incrementExpectedAwaits();\r\n    return possiblePromise.then(x => {\r\n      decrementExpectedAwaits();\r\n      return x;\r\n    }, e => {\r\n      decrementExpectedAwaits();\r\n      return rejection(e);\r\n    });\r\n  }\r\n  return possiblePromise;\r\n}\r\n\r\n\r\n/**\r\n * 現在設定されているPromiseのenvを生成しreturn.\r\n */\r\nfunction snapShot() {\r\n  var GlobalPromise = _functions_utils_js__WEBPACK_IMPORTED_MODULE_0__._global.Promise;\r\n  return _dexie_js__WEBPACK_IMPORTED_MODULE_2__.patchGlobalPromise ? {\r\n    Promise: GlobalPromise,\r\n    PromiseProp: Object.getOwnPropertyDescriptor(_functions_utils_js__WEBPACK_IMPORTED_MODULE_0__._global, \"Promise\"),\r\n    all: GlobalPromise.all,\r\n    race: GlobalPromise.race,\r\n    allSettled: GlobalPromise.allSettled,\r\n    any: GlobalPromise.any,\r\n    resolve: GlobalPromise.resolve,\r\n    reject: GlobalPromise.reject,\r\n    nthen: _dexie_js__WEBPACK_IMPORTED_MODULE_2__.nativePromiseProto.then,\r\n    gthen: GlobalPromise.prototype.then,\r\n  } : {};\r\n}\r\n\r\nfunction nativeAwaitCompatibleWrap(fn, zone, possibleAwait) {\r\n  console.log(\"nativeAwaitCompatibleWrap\");\r\n  return typeof fn !== \"function\" ? fn : function () {\r\n    var outerZone = PSD;\r\n    console.group(\"nativeAwaitCompatibleWrapped\");\r\n    if (possibleAwait) incrementExpectedAwaits();\r\n    switchToZone(zone, true);\r\n    try {\r\n      return fn.apply(this, arguments);\r\n    } finally {\r\n      switchToZone(outerZone, false);\r\n      console.groupEnd();\r\n    }\r\n  };\r\n}\r\n\r\n\r\n/**\r\n * onFulfilled, onRejectedをラップしたthenを作成し, return。\r\n * onFulfilled, onRejectedを実行している間、zoneが切り替わる。\r\n * @param {*} origThen\r\n * @param {*} zone\r\n */\r\nfunction getPatchedPromiseThen(origThen, zone) {\r\n  return function (onFulfilled, onRejected) {\r\n    return origThen.call(this,\r\n      nativeAwaitCompatibleWrap(onFulfilled, zone, false),\r\n      nativeAwaitCompatibleWrap(onRejected, zone, false));\r\n  };\r\n}\r\n\r\nconst UNHANDLEDREJECTION = \"unhandledrejection\";\r\n\r\nfunction globalError(err, promise) {\r\n  var rv;\r\n  try {\r\n    rv = promise.onuncatched(err);\r\n  } catch (e) { }\r\n  if (rv !== false) try {\r\n    var event, eventData = { promise: promise, reason: err };\r\n    if (_functions_utils_js__WEBPACK_IMPORTED_MODULE_0__._global.document && document.createEvent) {\r\n      event = document.createEvent(\"Event\");\r\n      event.initEvent(UNHANDLEDREJECTION, true, true);\r\n      (0,_functions_utils_js__WEBPACK_IMPORTED_MODULE_0__.extend)(event, eventData);\r\n    } else if (_functions_utils_js__WEBPACK_IMPORTED_MODULE_0__._global.CustomEvent) {\r\n      event = new CustomEvent(UNHANDLEDREJECTION, { detail: eventData });\r\n      (0,_functions_utils_js__WEBPACK_IMPORTED_MODULE_0__.extend)(event, eventData);\r\n    }\r\n    if (event && _functions_utils_js__WEBPACK_IMPORTED_MODULE_0__._global.dispatchEvent) {\r\n      dispatchEvent(event);\r\n      if (!_functions_utils_js__WEBPACK_IMPORTED_MODULE_0__._global.PromiseRejectionEvent && _functions_utils_js__WEBPACK_IMPORTED_MODULE_0__._global.onunhandledrejection)\r\n        // No native support for PromiseRejectionEvent but user has set window.onunhandledrejection. Manually call it.\r\n        try { _functions_utils_js__WEBPACK_IMPORTED_MODULE_0__._global.onunhandledrejection(event); } catch (_) { }\r\n    }\r\n    if (_debug_js__WEBPACK_IMPORTED_MODULE_1__.debug && event && !event.defaultPrevented) {\r\n      console.warn(`Unhandled rejection: ${err.stack || err}`);\r\n    }\r\n  } catch (e) { }\r\n}\r\n\r\nvar rejection = _dexie_js__WEBPACK_IMPORTED_MODULE_2__.default.reject;\r\n\r\n// export class Zone {\r\n//   static get current() {\r\n//     return DexiePromise.PSD;\r\n//   }\r\n// }\r\n\r\n\r\n// export function wrap(fn, errorCatcher) {\r\n//     var psd = PSD;\r\n//     return function () {\r\n//         var wasRootExec = beginMicroTickScope(),\r\n//             outerScope = PSD;\r\n\r\n//         try {\r\n//             switchToZone(psd, true);\r\n//             return fn.apply(this, arguments);\r\n//         } catch (e) {\r\n//             errorCatcher && errorCatcher(e);\r\n//         } finally {\r\n//             switchToZone(outerScope, false);\r\n//             if (wasRootExec) endMicroTickScope();\r\n//         }\r\n//     };\r\n// }\r\n\r\n\r\n// if ((\"\" + nativePromiseThen).indexOf(\"[native code]\") === -1) {\r\n//     // If the native promise\" prototype is patched, we cannot rely on zone echoing.\r\n//     // Disable that here:\r\n//     incrementExpectedAwaits = decrementExpectedAwaits = nop;\r\n// }\r\n\r\n\r\n// let __zone_id__ = 1;\r\n// export function lZone(zone) {\r\n//     if (!zone) {\r\n//         return \"!NO ZONE!\"\r\n//     }\r\n\r\n//     if (!zone.hasOwnProperty(\"__id__\")) {\r\n//         zone.__id__ = __zone_id__++;\r\n//     }\r\n//     return zone.__id__ + (zone.global ? \"g\" : \"\");\r\n// }\r\n// export function getFrame() {\r\n//     var o = {}\r\n//     Error.captureStackTrace(o, getFrame)\r\n\r\n//     const frames = o.stack.split(\"\\n\");\r\n//     const topMostFrame = frames[1]\r\n//         .replace(/^\\s*at\\s/, \"\")\r\n//         .replace(/\\s\\(.*\\)/, \"\");\r\n//     const callerFrame = frames[2] && frames[2].replace(/^\\s*at\\s/, \"\").replace(/\\(.+\\)/, \"\");\r\n//     const frame = topMostFrame + \" at \" + callerFrame;\r\n\r\n//     return `(${task.id} ${task.awaits} ${task.echoes} ${taskCounter} (${zoneStack.map(lZone).join(\",\")}) ${zoneEchoes} ${totalEchoes}) ${frame}`;\r\n\r\n// }\n\n//# sourceURL=webpack:///./context-zone/microTaskZone/helpers/psd.js?");

/***/ }),

/***/ "./context-zone/utils.js":
/*!*******************************!*\
  !*** ./context-zone/utils.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"useReplayLayerStack\": () => /* binding */ useReplayLayerStack,\n/* harmony export */   \"useReplayZoneCurrent\": () => /* binding */ useReplayZoneCurrent,\n/* harmony export */   \"generateOnInvokeTaskCallback\": () => /* binding */ generateOnInvokeTaskCallback,\n/* harmony export */   \"generateZoneName\": () => /* binding */ generateZoneName,\n/* harmony export */   \"applyToLayerStack\": () => /* binding */ applyToLayerStack,\n/* harmony export */   \"popFrame\": () => /* binding */ popFrame,\n/* harmony export */   \"pushFrame\": () => /* binding */ pushFrame,\n/* harmony export */   \"frameEquals\": () => /* binding */ frameEquals,\n/* harmony export */   \"getCurrentLayerStack\": () => /* binding */ getCurrentLayerStack\n/* harmony export */ });\n/* harmony import */ var zone_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! zone.js */ \"./node_modules/zone.js/fesm2015/zone.js\");\n/* harmony import */ var zone_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(zone_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _ContextJS_src_Layers_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ContextJS/src/Layers.js */ \"./ContextJS/src/Layers.js\");\n\r\n\r\n\r\n\r\n/**\r\n * return [restoreLayerStack, unrestoreLayerStack]\r\n */\r\nconst useReplayLayerStack = (frame, zoneName) => {\r\n  // const initLayerStack = getCurrentLayerStack();\r\n  const zonedLayerStack = getCurrentLayerStack();\r\n  frame.zoneName = zoneName;\r\n  zonedLayerStack.push(frame);\r\n\r\n  // LayerStackから_zoneNameのframeを削除\r\n  const deleteFromLayerStack = (_zoneName) => {\r\n    const targetIndex = _ContextJS_src_Layers_js__WEBPACK_IMPORTED_MODULE_1__.LayerStack.findIndex(elm => (\r\n      elm.zoneName === _zoneName\r\n    ));\r\n    if (targetIndex !== -1) {\r\n      _ContextJS_src_Layers_js__WEBPACK_IMPORTED_MODULE_1__.LayerStack.splice(targetIndex, 1);\r\n    }\r\n  }\r\n\r\n  const restoreLayerStack = () => {\r\n    applyToLayerStack(zonedLayerStack);\r\n  };\r\n  const unrestoreLayerStack = () => {\r\n    // deleteFromLayerStack(zoneName);\r\n    zonedLayerStack.forEach(_frame => {\r\n      if (_frame.zoneName) deleteFromLayerStack(_frame.zoneName);\r\n    });\r\n    console.error([..._ContextJS_src_Layers_js__WEBPACK_IMPORTED_MODULE_1__.LayerStack]);\r\n  };\r\n\r\n  return [restoreLayerStack, unrestoreLayerStack];\r\n}\r\n\r\n/**\r\n * return [replayZoneCurrentEnter, replayZoneCurrentLeave]\r\n */\r\nconst useReplayZoneCurrent = (zone, rootZone) => {\r\n  const replayZoneCurrent = (_zone) => {\r\n    Object.defineProperty(Zone, \"current\", {\r\n      value: _zone,\r\n      writable: true,\r\n      configurable: true,\r\n      enumerable: false,\r\n    });\r\n  }\r\n\r\n  const replayZoneCurrentEnter = () => replayZoneCurrent(zone);\r\n  const replayZoneCurrentLeave = () => replayZoneCurrent(rootZone);\r\n\r\n  return [replayZoneCurrentEnter, replayZoneCurrentLeave];\r\n}\r\n\r\n\r\nconst generateOnInvokeTaskCallback = (frame, zoneName) => {\r\n  const [restoreLayerStack, unrestoreLayerStack] = useReplayLayerStack(frame, zoneName);\r\n\r\n  return (delegate, curr, target, task, applyThis, applyArgs) => {\r\n    let _task = task;\r\n    if (task.type !== \"microTask\") {\r\n      _task = wrapCallbackTask(\r\n        task,\r\n        restoreLayerStack,\r\n        unrestoreLayerStack,\r\n      );\r\n    }\r\n\r\n    return delegate.invokeTask(target, _task, applyThis, applyArgs);\r\n  }\r\n}\r\n\r\n\r\nconst wrapCallbackTask = (task, invokeTaskCallback, endTaskCallback) => {\r\n  if (!task.isWrappedCallback) {\r\n    // not wrapped yet\r\n    const _callback = task.callback;\r\n\r\n    task.callback = function () {\r\n      invokeTaskCallback();\r\n      _callback.apply(this, arguments);\r\n      endTaskCallback();\r\n    }\r\n    task.isWrappedCallback = true;\r\n  } else {\r\n    // already wrapped\r\n    console.log(\"すでに包まれている\");\r\n  }\r\n\r\n  return task;\r\n}\r\n\r\n\r\n/**\r\n * zone nameの生成\r\n */\r\nconst generateZoneName = () => {\r\n  const chars = [];\r\n  for (const char of \"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\") {\r\n    switch (char) {\r\n      case \"x\":\r\n        chars.push(Math.floor(Math.random() * 16).toString(16));\r\n        break;\r\n      case \"y\":\r\n        chars.push((Math.floor(Math.random() * 4) + 8).toString(16));\r\n        break;\r\n      default:\r\n        chars.push(char);\r\n        break;\r\n    }\r\n  }\r\n  return chars.join(\"\");\r\n};\r\n\r\nfunction applyToLayerStack(from) {\r\n  const fromLength = from.length;\r\n  const LayerStackLength = _ContextJS_src_Layers_js__WEBPACK_IMPORTED_MODULE_1__.LayerStack.length;\r\n  const maxLengthCommonAncestry = Math.min(fromLength, LayerStackLength);\r\n  let commonAncestryLength = 0;\r\n\r\n  while (commonAncestryLength < maxLengthCommonAncestry && from[commonAncestryLength]?.zoneName === _ContextJS_src_Layers_js__WEBPACK_IMPORTED_MODULE_1__.LayerStack[commonAncestryLength]?.zoneName) {\r\n    commonAncestryLength++;\r\n  }\r\n\r\n  while (_ContextJS_src_Layers_js__WEBPACK_IMPORTED_MODULE_1__.LayerStack.length > commonAncestryLength) {\r\n    popFrame();\r\n  }\r\n  while (_ContextJS_src_Layers_js__WEBPACK_IMPORTED_MODULE_1__.LayerStack.length < fromLength) {\r\n    pushFrame(from[_ContextJS_src_Layers_js__WEBPACK_IMPORTED_MODULE_1__.LayerStack.length]);\r\n  }\r\n}\r\n\r\nfunction popFrame() {\r\n  const beforePop = (0,_ContextJS_src_Layers_js__WEBPACK_IMPORTED_MODULE_1__.currentLayers)();\r\n\r\n  const frame = _ContextJS_src_Layers_js__WEBPACK_IMPORTED_MODULE_1__.LayerStack.pop();\r\n  const { withLayers, withoutLayers } = frame;\r\n\r\n  const afterPop = (0,_ContextJS_src_Layers_js__WEBPACK_IMPORTED_MODULE_1__.currentLayers)();\r\n\r\n  // #TODO: we should probably .reverse() the list to deactivate the last activated layer first\r\n  withLayers && withLayers\r\n    .filter(l => beforePop.includes(l) && !afterPop.includes(l))\r\n    .forEach(l => l._emitDeactivateCallbacks());\r\n\r\n  withoutLayers && withoutLayers\r\n    .filter(l => !beforePop.includes(l) && afterPop.includes(l))\r\n    .forEach(l => l._emitActivateCallbacks());\r\n}\r\n\r\nfunction pushFrame(frame) {\r\n  const { withLayers, withoutLayers } = frame;\r\n\r\n  const beforePush = (0,_ContextJS_src_Layers_js__WEBPACK_IMPORTED_MODULE_1__.currentLayers)();\r\n\r\n  _ContextJS_src_Layers_js__WEBPACK_IMPORTED_MODULE_1__.LayerStack.push(frame);\r\n\r\n  withLayers && withLayers\r\n    .filter(l => !beforePush.includes(l))\r\n    .forEach(l => l._emitActivateCallbacks());\r\n\r\n  withoutLayers && withoutLayers\r\n    .filter(l => beforePush.includes(l))\r\n    .forEach(l => l._emitDeactivateCallbacks());\r\n}\r\n\r\nfunction frameEquals(frame1, frame2) {\r\n  const layerListProperties = [\"withLayers\", \"withoutLayers\"];\r\n\r\n  // all props are StrictEqual, except withLayers and withoutLayers\r\n  const shallowCompare = (obj1, obj2) =>\r\n    Object.keys(obj1).length === Object.keys(obj2).length &&\r\n    Object.keys(obj1).every(key => {\r\n      if (layerListProperties.includes(key)) {\r\n        return true; // checked later\r\n      }\r\n      return obj2.hasOwnProperty(key) && obj1[key] === obj2[key]\r\n    });\r\n\r\n  if (!shallowCompare(frame1, frame2)) { return false; }\r\n\r\n  // withLayers and withoutLayers should contain the same layers in order\r\n  return layerListProperties.every(prop => {\r\n    const arr1 = frame1[prop];\r\n    const arr2 = frame2[prop];\r\n    if (arr1 && arr2) { // both have prop set\r\n      if (!Array.isArray(arr1) || !Array.isArray(arr2) || arr1.length !== arr2.length) {\r\n        return false;\r\n      }\r\n      return arr1.every((layer, index) => layer === arr2[index]);\r\n    }\r\n\r\n    return !arr1 && !arr2; // both do not define the prop is fine, too\r\n  });\r\n}\r\n\r\n\r\nfunction getCurrentLayerStack() {\r\n  return _ContextJS_src_Layers_js__WEBPACK_IMPORTED_MODULE_1__.LayerStack.map((frame) => {\r\n    const resultFrame = {};\r\n\r\n    // use copied arrays of layers\r\n    if (frame.withLayers) {\r\n      resultFrame.withLayers = Array.from(frame.withLayers)\r\n    }\r\n    if (frame.withoutLayers) {\r\n      resultFrame.withoutLayers = Array.from(frame.withoutLayers)\r\n    }\r\n\r\n    return Object.assign(resultFrame, frame);\r\n  });\r\n}\n\n//# sourceURL=webpack:///./context-zone/utils.js?");

/***/ }),

/***/ "./experiments/microTask/js/main.js":
/*!******************************************!*\
  !*** ./experiments/microTask/js/main.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _context_zone_contextZone_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../context-zone/contextZone.js */ \"./context-zone/contextZone.js\");\n/* harmony import */ var _ContextJS_src_contextjs_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../ContextJS/src/contextjs.js */ \"./ContextJS/src/contextjs.js\");\n/* harmony import */ var _tokens_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./tokens.js */ \"./experiments/microTask/js/tokens.js\");\n\r\n\r\n\r\n\r\n\r\nconst authHeader = {\r\n  Authorization: `Bearer ${_tokens_js__WEBPACK_IMPORTED_MODULE_2__.ACCESS_TOKEN}`,\r\n}\r\n\r\nconst BASE_URL = \"https://qiita.com/api/v2/\";\r\nconst POSTS_URL = \"items\";\r\nconst USERS_URL = \"users\";\r\nconst requestQiita = (url, isAuth, thenCallback) => {\r\n  fetch(url, {\r\n    method: \"GET\",\r\n    mode: \"cors\",\r\n    headers: {\r\n      \"Content-Type\": \"application/json\",\r\n      ...isAuth && authHeader,\r\n    }\r\n  })\r\n    .then(response => response.json())\r\n    .then(thenCallback);\r\n}\r\n\r\nclass ListRenderer {\r\n  constructor() {\r\n    this.listElm = this.getListElm();\r\n  }\r\n  getListElm() {\r\n    return document.getElementById(\"post-list\");\r\n  }\r\n  renderCard(title, subTitle, id) {\r\n    const cardElm = document.createElement(\"div\");\r\n    cardElm.classList.add(\"card\", \"mt-3\", \"shadow-sm\");\r\n    cardElm.id = id;\r\n    const cardBody = `\r\n    <div class=\"card-body\">\r\n      <h5 class=\"card-title\">${title ? title : \"-\"}</h5>\r\n      <h6 class=\"card-subtitle mb-2 text-muted\">${subTitle ? subTitle : \"-\"}</h6>\r\n    </div>\r\n    `;\r\n    cardElm.innerHTML = cardBody;\r\n    return cardElm;\r\n  }\r\n  renderList(listDataSet) {\r\n    listDataSet.forEach(listData => {\r\n      const card = this.renderCard(listData.title, listData.subTitle, listData.id);\r\n      this.listElm.appendChild(card);\r\n    });\r\n  }\r\n}\r\n\r\nclass RequestClient {\r\n  getUrl() {\r\n    return BASE_URL + POSTS_URL;\r\n  }\r\n  getTitle(item) {\r\n    return item.title;\r\n  }\r\n  getSubTitle(item) {\r\n    const date = new Date(item.updated_at);\r\n    return `${date.getFullYear()}/${date.getMonth() + 1}/${date.getDate()}`;\r\n  }\r\n  getId(item) {\r\n    return item.id;\r\n  }\r\n  parseItems(items) {\r\n    return items.map(item => {\r\n      return {\r\n        title: this.getTitle(item),\r\n        subTitle: this.getSubTitle(item),\r\n        id: this.getId(item),\r\n      }\r\n    })\r\n  }\r\n  request(task) {\r\n    requestQiita(this.getUrl(), true, task);\r\n  }\r\n}\r\n\r\nconst userListLayer = (0,_ContextJS_src_contextjs_js__WEBPACK_IMPORTED_MODULE_1__.layer)(\"userListLayer\");\r\nuserListLayer.refineClass(ListRenderer, {\r\n  getListElm() {\r\n    return document.getElementById(\"user-list\");\r\n  }\r\n});\r\nuserListLayer.refineClass(RequestClient, {\r\n  getUrl() {\r\n    return BASE_URL + USERS_URL;\r\n  },\r\n  getTitle(item) {\r\n    return item.id;\r\n  },\r\n  getSubTitle(item) {\r\n    return `フォロー数: ${item.followees_count}, フォロワー数: ${item.followers_count}`;\r\n  },\r\n  getId(item) {\r\n    return item.id;\r\n  },\r\n});\r\n\r\nconst displayList = () => {\r\n  const requestClient = new RequestClient();\r\n  const listRenderer = new ListRenderer();\r\n\r\n  requestClient.request((data) => {\r\n    console.log(data);\r\n    const items = Object.values(data);\r\n    const listDataSet = requestClient.parseItems(items);\r\n    listRenderer.renderList(listDataSet);\r\n\r\n    defineClickEvent(listRenderer.listElm); // EventTask. cardが生成されてからevent定義\r\n  });\r\n}\r\n\r\n/** MicroTask\r\n * 違い: 既存手法では、ユーザのtitle, subtitleが崩れる(titleやらupdated_atやら存在しないkeyを指定されるため).\r\n */\r\ndisplayList();\r\n(0,_ContextJS_src_contextjs_js__WEBPACK_IMPORTED_MODULE_1__.withLayers)([userListLayer], displayList);\r\n// withLayersZone([userListLayer], displayList);\r\n\r\n\r\nclass ClickEventDefiner {\r\n  geneDetailUrl(elm) {\r\n    return `/post/${elm.id}`;\r\n  }\r\n  define(elm) {\r\n    elm.addEventListener(\"click\", () => {\r\n      console.log(this.geneDetailUrl(elm)); // 疑似request\r\n    });\r\n  }\r\n}\r\n\r\nuserListLayer.refineClass(ClickEventDefiner, {\r\n  geneDetailUrl(elm) {\r\n    return `/user/${elm.id}`;\r\n  }\r\n});\r\n\r\nconst defineClickEvent = (listElm) => {\r\n  const clickEventDefiner = new ClickEventDefiner();\r\n  Array.prototype.forEach.call(listElm.children, cardElm => {\r\n    clickEventDefiner.define(cardElm);\r\n  });\r\n}\r\n\r\n/** EventTask\r\n * 違い: 生成されたurlが既存手法ではどちらもpost/...となってしまう。\r\n */\r\n// withLayersZone([userListLayer], defineClickEvent); // まだcardが生成されていない\r\n\r\n\r\n/** MacroTask\r\n * 違い:\r\n */\n\n//# sourceURL=webpack:///./experiments/microTask/js/main.js?");

/***/ }),

/***/ "./experiments/microTask/js/tokens.js":
/*!********************************************!*\
  !*** ./experiments/microTask/js/tokens.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ACCESS_TOKEN\": () => /* binding */ ACCESS_TOKEN\n/* harmony export */ });\nconst ACCESS_TOKEN = \"a2f5511c9c01e95be0d23b46a7b172a6c31c38bb\";\n\n//# sourceURL=webpack:///./experiments/microTask/js/tokens.js?");

/***/ }),

/***/ "./node_modules/zone.js/fesm2015/zone.js":
/*!***********************************************!*\
  !*** ./node_modules/zone.js/fesm2015/zone.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n* @license Angular v11.0.0-next.6+162.sha-170af07\n* (c) 2010-2020 Google LLC. https://angular.io/\n* License: MIT\n*/\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nconst Zone$1 = (function (global) {\n    const performance = global['performance'];\n    function mark(name) {\n        performance && performance['mark'] && performance['mark'](name);\n    }\n    function performanceMeasure(name, label) {\n        performance && performance['measure'] && performance['measure'](name, label);\n    }\n    mark('Zone');\n    // Initialize before it's accessed below.\n    // __Zone_symbol_prefix global can be used to override the default zone\n    // symbol prefix with a custom one if needed.\n    const symbolPrefix = global['__Zone_symbol_prefix'] || '__zone_symbol__';\n    function __symbol__(name) {\n        return symbolPrefix + name;\n    }\n    const checkDuplicate = global[__symbol__('forceDuplicateZoneCheck')] === true;\n    if (global['Zone']) {\n        // if global['Zone'] already exists (maybe zone.js was already loaded or\n        // some other lib also registered a global object named Zone), we may need\n        // to throw an error, but sometimes user may not want this error.\n        // For example,\n        // we have two web pages, page1 includes zone.js, page2 doesn't.\n        // and the 1st time user load page1 and page2, everything work fine,\n        // but when user load page2 again, error occurs because global['Zone'] already exists.\n        // so we add a flag to let user choose whether to throw this error or not.\n        // By default, if existing Zone is from zone.js, we will not throw the error.\n        if (checkDuplicate || typeof global['Zone'].__symbol__ !== 'function') {\n            throw new Error('Zone already loaded.');\n        }\n        else {\n            return global['Zone'];\n        }\n    }\n    class Zone {\n        constructor(parent, zoneSpec) {\n            this._parent = parent;\n            this._name = zoneSpec ? zoneSpec.name || 'unnamed' : '<root>';\n            this._properties = zoneSpec && zoneSpec.properties || {};\n            this._zoneDelegate =\n                new ZoneDelegate(this, this._parent && this._parent._zoneDelegate, zoneSpec);\n        }\n        static assertZonePatched() {\n            if (global['Promise'] !== patches['ZoneAwarePromise']) {\n                throw new Error('Zone.js has detected that ZoneAwarePromise `(window|global).Promise` ' +\n                    'has been overwritten.\\n' +\n                    'Most likely cause is that a Promise polyfill has been loaded ' +\n                    'after Zone.js (Polyfilling Promise api is not necessary when zone.js is loaded. ' +\n                    'If you must load one, do so before loading zone.js.)');\n            }\n        }\n        static get root() {\n            let zone = Zone.current;\n            while (zone.parent) {\n                zone = zone.parent;\n            }\n            return zone;\n        }\n        static get current() {\n            return _currentZoneFrame.zone;\n        }\n        static get currentTask() {\n            return _currentTask;\n        }\n        // tslint:disable-next-line:require-internal-with-underscore\n        static __load_patch(name, fn) {\n            if (patches.hasOwnProperty(name)) {\n                if (checkDuplicate) {\n                    throw Error('Already loaded patch: ' + name);\n                }\n            }\n            else if (!global['__Zone_disable_' + name]) {\n                const perfName = 'Zone:' + name;\n                mark(perfName);\n                patches[name] = fn(global, Zone, _api);\n                performanceMeasure(perfName, perfName);\n            }\n        }\n        get parent() {\n            return this._parent;\n        }\n        get name() {\n            return this._name;\n        }\n        get(key) {\n            const zone = this.getZoneWith(key);\n            if (zone)\n                return zone._properties[key];\n        }\n        getZoneWith(key) {\n            let current = this;\n            while (current) {\n                if (current._properties.hasOwnProperty(key)) {\n                    return current;\n                }\n                current = current._parent;\n            }\n            return null;\n        }\n        fork(zoneSpec) {\n            if (!zoneSpec)\n                throw new Error('ZoneSpec required!');\n            return this._zoneDelegate.fork(this, zoneSpec);\n        }\n        wrap(callback, source) {\n            if (typeof callback !== 'function') {\n                throw new Error('Expecting function got: ' + callback);\n            }\n            const _callback = this._zoneDelegate.intercept(this, callback, source);\n            const zone = this;\n            return function () {\n                return zone.runGuarded(_callback, this, arguments, source);\n            };\n        }\n        run(callback, applyThis, applyArgs, source) {\n            _currentZoneFrame = { parent: _currentZoneFrame, zone: this };\n            try {\n                return this._zoneDelegate.invoke(this, callback, applyThis, applyArgs, source);\n            }\n            finally {\n                _currentZoneFrame = _currentZoneFrame.parent;\n            }\n        }\n        runGuarded(callback, applyThis = null, applyArgs, source) {\n            _currentZoneFrame = { parent: _currentZoneFrame, zone: this };\n            try {\n                try {\n                    return this._zoneDelegate.invoke(this, callback, applyThis, applyArgs, source);\n                }\n                catch (error) {\n                    if (this._zoneDelegate.handleError(this, error)) {\n                        throw error;\n                    }\n                }\n            }\n            finally {\n                _currentZoneFrame = _currentZoneFrame.parent;\n            }\n        }\n        runTask(task, applyThis, applyArgs) {\n            if (task.zone != this) {\n                throw new Error('A task can only be run in the zone of creation! (Creation: ' +\n                    (task.zone || NO_ZONE).name + '; Execution: ' + this.name + ')');\n            }\n            // https://github.com/angular/zone.js/issues/778, sometimes eventTask\n            // will run in notScheduled(canceled) state, we should not try to\n            // run such kind of task but just return\n            if (task.state === notScheduled && (task.type === eventTask || task.type === macroTask)) {\n                return;\n            }\n            const reEntryGuard = task.state != running;\n            reEntryGuard && task._transitionTo(running, scheduled);\n            task.runCount++;\n            const previousTask = _currentTask;\n            _currentTask = task;\n            _currentZoneFrame = { parent: _currentZoneFrame, zone: this };\n            try {\n                if (task.type == macroTask && task.data && !task.data.isPeriodic) {\n                    task.cancelFn = undefined;\n                }\n                try {\n                    return this._zoneDelegate.invokeTask(this, task, applyThis, applyArgs);\n                }\n                catch (error) {\n                    if (this._zoneDelegate.handleError(this, error)) {\n                        throw error;\n                    }\n                }\n            }\n            finally {\n                // if the task's state is notScheduled or unknown, then it has already been cancelled\n                // we should not reset the state to scheduled\n                if (task.state !== notScheduled && task.state !== unknown) {\n                    if (task.type == eventTask || (task.data && task.data.isPeriodic)) {\n                        reEntryGuard && task._transitionTo(scheduled, running);\n                    }\n                    else {\n                        task.runCount = 0;\n                        this._updateTaskCount(task, -1);\n                        reEntryGuard &&\n                            task._transitionTo(notScheduled, running, notScheduled);\n                    }\n                }\n                _currentZoneFrame = _currentZoneFrame.parent;\n                _currentTask = previousTask;\n            }\n        }\n        scheduleTask(task) {\n            if (task.zone && task.zone !== this) {\n                // check if the task was rescheduled, the newZone\n                // should not be the children of the original zone\n                let newZone = this;\n                while (newZone) {\n                    if (newZone === task.zone) {\n                        throw Error(`can not reschedule task to ${this.name} which is descendants of the original zone ${task.zone.name}`);\n                    }\n                    newZone = newZone.parent;\n                }\n            }\n            task._transitionTo(scheduling, notScheduled);\n            const zoneDelegates = [];\n            task._zoneDelegates = zoneDelegates;\n            task._zone = this;\n            try {\n                task = this._zoneDelegate.scheduleTask(this, task);\n            }\n            catch (err) {\n                // should set task's state to unknown when scheduleTask throw error\n                // because the err may from reschedule, so the fromState maybe notScheduled\n                task._transitionTo(unknown, scheduling, notScheduled);\n                // TODO: @JiaLiPassion, should we check the result from handleError?\n                this._zoneDelegate.handleError(this, err);\n                throw err;\n            }\n            if (task._zoneDelegates === zoneDelegates) {\n                // we have to check because internally the delegate can reschedule the task.\n                this._updateTaskCount(task, 1);\n            }\n            if (task.state == scheduling) {\n                task._transitionTo(scheduled, scheduling);\n            }\n            return task;\n        }\n        scheduleMicroTask(source, callback, data, customSchedule) {\n            return this.scheduleTask(new ZoneTask(microTask, source, callback, data, customSchedule, undefined));\n        }\n        scheduleMacroTask(source, callback, data, customSchedule, customCancel) {\n            return this.scheduleTask(new ZoneTask(macroTask, source, callback, data, customSchedule, customCancel));\n        }\n        scheduleEventTask(source, callback, data, customSchedule, customCancel) {\n            return this.scheduleTask(new ZoneTask(eventTask, source, callback, data, customSchedule, customCancel));\n        }\n        cancelTask(task) {\n            if (task.zone != this)\n                throw new Error('A task can only be cancelled in the zone of creation! (Creation: ' +\n                    (task.zone || NO_ZONE).name + '; Execution: ' + this.name + ')');\n            task._transitionTo(canceling, scheduled, running);\n            try {\n                this._zoneDelegate.cancelTask(this, task);\n            }\n            catch (err) {\n                // if error occurs when cancelTask, transit the state to unknown\n                task._transitionTo(unknown, canceling);\n                this._zoneDelegate.handleError(this, err);\n                throw err;\n            }\n            this._updateTaskCount(task, -1);\n            task._transitionTo(notScheduled, canceling);\n            task.runCount = 0;\n            return task;\n        }\n        _updateTaskCount(task, count) {\n            const zoneDelegates = task._zoneDelegates;\n            if (count == -1) {\n                task._zoneDelegates = null;\n            }\n            for (let i = 0; i < zoneDelegates.length; i++) {\n                zoneDelegates[i]._updateTaskCount(task.type, count);\n            }\n        }\n    }\n    // tslint:disable-next-line:require-internal-with-underscore\n    Zone.__symbol__ = __symbol__;\n    const DELEGATE_ZS = {\n        name: '',\n        onHasTask: (delegate, _, target, hasTaskState) => delegate.hasTask(target, hasTaskState),\n        onScheduleTask: (delegate, _, target, task) => delegate.scheduleTask(target, task),\n        onInvokeTask: (delegate, _, target, task, applyThis, applyArgs) => delegate.invokeTask(target, task, applyThis, applyArgs),\n        onCancelTask: (delegate, _, target, task) => delegate.cancelTask(target, task)\n    };\n    class ZoneDelegate {\n        constructor(zone, parentDelegate, zoneSpec) {\n            this._taskCounts = { 'microTask': 0, 'macroTask': 0, 'eventTask': 0 };\n            this.zone = zone;\n            this._parentDelegate = parentDelegate;\n            this._forkZS = zoneSpec && (zoneSpec && zoneSpec.onFork ? zoneSpec : parentDelegate._forkZS);\n            this._forkDlgt = zoneSpec && (zoneSpec.onFork ? parentDelegate : parentDelegate._forkDlgt);\n            this._forkCurrZone =\n                zoneSpec && (zoneSpec.onFork ? this.zone : parentDelegate._forkCurrZone);\n            this._interceptZS =\n                zoneSpec && (zoneSpec.onIntercept ? zoneSpec : parentDelegate._interceptZS);\n            this._interceptDlgt =\n                zoneSpec && (zoneSpec.onIntercept ? parentDelegate : parentDelegate._interceptDlgt);\n            this._interceptCurrZone =\n                zoneSpec && (zoneSpec.onIntercept ? this.zone : parentDelegate._interceptCurrZone);\n            this._invokeZS = zoneSpec && (zoneSpec.onInvoke ? zoneSpec : parentDelegate._invokeZS);\n            this._invokeDlgt =\n                zoneSpec && (zoneSpec.onInvoke ? parentDelegate : parentDelegate._invokeDlgt);\n            this._invokeCurrZone =\n                zoneSpec && (zoneSpec.onInvoke ? this.zone : parentDelegate._invokeCurrZone);\n            this._handleErrorZS =\n                zoneSpec && (zoneSpec.onHandleError ? zoneSpec : parentDelegate._handleErrorZS);\n            this._handleErrorDlgt =\n                zoneSpec && (zoneSpec.onHandleError ? parentDelegate : parentDelegate._handleErrorDlgt);\n            this._handleErrorCurrZone =\n                zoneSpec && (zoneSpec.onHandleError ? this.zone : parentDelegate._handleErrorCurrZone);\n            this._scheduleTaskZS =\n                zoneSpec && (zoneSpec.onScheduleTask ? zoneSpec : parentDelegate._scheduleTaskZS);\n            this._scheduleTaskDlgt = zoneSpec &&\n                (zoneSpec.onScheduleTask ? parentDelegate : parentDelegate._scheduleTaskDlgt);\n            this._scheduleTaskCurrZone =\n                zoneSpec && (zoneSpec.onScheduleTask ? this.zone : parentDelegate._scheduleTaskCurrZone);\n            this._invokeTaskZS =\n                zoneSpec && (zoneSpec.onInvokeTask ? zoneSpec : parentDelegate._invokeTaskZS);\n            this._invokeTaskDlgt =\n                zoneSpec && (zoneSpec.onInvokeTask ? parentDelegate : parentDelegate._invokeTaskDlgt);\n            this._invokeTaskCurrZone =\n                zoneSpec && (zoneSpec.onInvokeTask ? this.zone : parentDelegate._invokeTaskCurrZone);\n            this._cancelTaskZS =\n                zoneSpec && (zoneSpec.onCancelTask ? zoneSpec : parentDelegate._cancelTaskZS);\n            this._cancelTaskDlgt =\n                zoneSpec && (zoneSpec.onCancelTask ? parentDelegate : parentDelegate._cancelTaskDlgt);\n            this._cancelTaskCurrZone =\n                zoneSpec && (zoneSpec.onCancelTask ? this.zone : parentDelegate._cancelTaskCurrZone);\n            this._hasTaskZS = null;\n            this._hasTaskDlgt = null;\n            this._hasTaskDlgtOwner = null;\n            this._hasTaskCurrZone = null;\n            const zoneSpecHasTask = zoneSpec && zoneSpec.onHasTask;\n            const parentHasTask = parentDelegate && parentDelegate._hasTaskZS;\n            if (zoneSpecHasTask || parentHasTask) {\n                // If we need to report hasTask, than this ZS needs to do ref counting on tasks. In such\n                // a case all task related interceptors must go through this ZD. We can't short circuit it.\n                this._hasTaskZS = zoneSpecHasTask ? zoneSpec : DELEGATE_ZS;\n                this._hasTaskDlgt = parentDelegate;\n                this._hasTaskDlgtOwner = this;\n                this._hasTaskCurrZone = zone;\n                if (!zoneSpec.onScheduleTask) {\n                    this._scheduleTaskZS = DELEGATE_ZS;\n                    this._scheduleTaskDlgt = parentDelegate;\n                    this._scheduleTaskCurrZone = this.zone;\n                }\n                if (!zoneSpec.onInvokeTask) {\n                    this._invokeTaskZS = DELEGATE_ZS;\n                    this._invokeTaskDlgt = parentDelegate;\n                    this._invokeTaskCurrZone = this.zone;\n                }\n                if (!zoneSpec.onCancelTask) {\n                    this._cancelTaskZS = DELEGATE_ZS;\n                    this._cancelTaskDlgt = parentDelegate;\n                    this._cancelTaskCurrZone = this.zone;\n                }\n            }\n        }\n        fork(targetZone, zoneSpec) {\n            return this._forkZS ? this._forkZS.onFork(this._forkDlgt, this.zone, targetZone, zoneSpec) :\n                new Zone(targetZone, zoneSpec);\n        }\n        intercept(targetZone, callback, source) {\n            return this._interceptZS ?\n                this._interceptZS.onIntercept(this._interceptDlgt, this._interceptCurrZone, targetZone, callback, source) :\n                callback;\n        }\n        invoke(targetZone, callback, applyThis, applyArgs, source) {\n            return this._invokeZS ? this._invokeZS.onInvoke(this._invokeDlgt, this._invokeCurrZone, targetZone, callback, applyThis, applyArgs, source) :\n                callback.apply(applyThis, applyArgs);\n        }\n        handleError(targetZone, error) {\n            return this._handleErrorZS ?\n                this._handleErrorZS.onHandleError(this._handleErrorDlgt, this._handleErrorCurrZone, targetZone, error) :\n                true;\n        }\n        scheduleTask(targetZone, task) {\n            let returnTask = task;\n            if (this._scheduleTaskZS) {\n                if (this._hasTaskZS) {\n                    returnTask._zoneDelegates.push(this._hasTaskDlgtOwner);\n                }\n                // clang-format off\n                returnTask = this._scheduleTaskZS.onScheduleTask(this._scheduleTaskDlgt, this._scheduleTaskCurrZone, targetZone, task);\n                // clang-format on\n                if (!returnTask)\n                    returnTask = task;\n            }\n            else {\n                if (task.scheduleFn) {\n                    task.scheduleFn(task);\n                }\n                else if (task.type == microTask) {\n                    scheduleMicroTask(task);\n                }\n                else {\n                    throw new Error('Task is missing scheduleFn.');\n                }\n            }\n            return returnTask;\n        }\n        invokeTask(targetZone, task, applyThis, applyArgs) {\n            return this._invokeTaskZS ? this._invokeTaskZS.onInvokeTask(this._invokeTaskDlgt, this._invokeTaskCurrZone, targetZone, task, applyThis, applyArgs) :\n                task.callback.apply(applyThis, applyArgs);\n        }\n        cancelTask(targetZone, task) {\n            let value;\n            if (this._cancelTaskZS) {\n                value = this._cancelTaskZS.onCancelTask(this._cancelTaskDlgt, this._cancelTaskCurrZone, targetZone, task);\n            }\n            else {\n                if (!task.cancelFn) {\n                    throw Error('Task is not cancelable');\n                }\n                value = task.cancelFn(task);\n            }\n            return value;\n        }\n        hasTask(targetZone, isEmpty) {\n            // hasTask should not throw error so other ZoneDelegate\n            // can still trigger hasTask callback\n            try {\n                this._hasTaskZS &&\n                    this._hasTaskZS.onHasTask(this._hasTaskDlgt, this._hasTaskCurrZone, targetZone, isEmpty);\n            }\n            catch (err) {\n                this.handleError(targetZone, err);\n            }\n        }\n        // tslint:disable-next-line:require-internal-with-underscore\n        _updateTaskCount(type, count) {\n            const counts = this._taskCounts;\n            const prev = counts[type];\n            const next = counts[type] = prev + count;\n            if (next < 0) {\n                throw new Error('More tasks executed then were scheduled.');\n            }\n            if (prev == 0 || next == 0) {\n                const isEmpty = {\n                    microTask: counts['microTask'] > 0,\n                    macroTask: counts['macroTask'] > 0,\n                    eventTask: counts['eventTask'] > 0,\n                    change: type\n                };\n                this.hasTask(this.zone, isEmpty);\n            }\n        }\n    }\n    class ZoneTask {\n        constructor(type, source, callback, options, scheduleFn, cancelFn) {\n            // tslint:disable-next-line:require-internal-with-underscore\n            this._zone = null;\n            this.runCount = 0;\n            // tslint:disable-next-line:require-internal-with-underscore\n            this._zoneDelegates = null;\n            // tslint:disable-next-line:require-internal-with-underscore\n            this._state = 'notScheduled';\n            this.type = type;\n            this.source = source;\n            this.data = options;\n            this.scheduleFn = scheduleFn;\n            this.cancelFn = cancelFn;\n            if (!callback) {\n                throw new Error('callback is not defined');\n            }\n            this.callback = callback;\n            const self = this;\n            // TODO: @JiaLiPassion options should have interface\n            if (type === eventTask && options && options.useG) {\n                this.invoke = ZoneTask.invokeTask;\n            }\n            else {\n                this.invoke = function () {\n                    return ZoneTask.invokeTask.call(global, self, this, arguments);\n                };\n            }\n        }\n        static invokeTask(task, target, args) {\n            if (!task) {\n                task = this;\n            }\n            _numberOfNestedTaskFrames++;\n            try {\n                task.runCount++;\n                return task.zone.runTask(task, target, args);\n            }\n            finally {\n                if (_numberOfNestedTaskFrames == 1) {\n                    drainMicroTaskQueue();\n                }\n                _numberOfNestedTaskFrames--;\n            }\n        }\n        get zone() {\n            return this._zone;\n        }\n        get state() {\n            return this._state;\n        }\n        cancelScheduleRequest() {\n            this._transitionTo(notScheduled, scheduling);\n        }\n        // tslint:disable-next-line:require-internal-with-underscore\n        _transitionTo(toState, fromState1, fromState2) {\n            if (this._state === fromState1 || this._state === fromState2) {\n                this._state = toState;\n                if (toState == notScheduled) {\n                    this._zoneDelegates = null;\n                }\n            }\n            else {\n                throw new Error(`${this.type} '${this.source}': can not transition to '${toState}', expecting state '${fromState1}'${fromState2 ? ' or \\'' + fromState2 + '\\'' : ''}, was '${this._state}'.`);\n            }\n        }\n        toString() {\n            if (this.data && typeof this.data.handleId !== 'undefined') {\n                return this.data.handleId.toString();\n            }\n            else {\n                return Object.prototype.toString.call(this);\n            }\n        }\n        // add toJSON method to prevent cyclic error when\n        // call JSON.stringify(zoneTask)\n        toJSON() {\n            return {\n                type: this.type,\n                state: this.state,\n                source: this.source,\n                zone: this.zone.name,\n                runCount: this.runCount\n            };\n        }\n    }\n    //////////////////////////////////////////////////////\n    //////////////////////////////////////////////////////\n    ///  MICROTASK QUEUE\n    //////////////////////////////////////////////////////\n    //////////////////////////////////////////////////////\n    const symbolSetTimeout = __symbol__('setTimeout');\n    const symbolPromise = __symbol__('Promise');\n    const symbolThen = __symbol__('then');\n    let _microTaskQueue = [];\n    let _isDrainingMicrotaskQueue = false;\n    let nativeMicroTaskQueuePromise;\n    function scheduleMicroTask(task) {\n        // if we are not running in any task, and there has not been anything scheduled\n        // we must bootstrap the initial task creation by manually scheduling the drain\n        if (_numberOfNestedTaskFrames === 0 && _microTaskQueue.length === 0) {\n            // We are not running in Task, so we need to kickstart the microtask queue.\n            if (!nativeMicroTaskQueuePromise) {\n                if (global[symbolPromise]) {\n                    nativeMicroTaskQueuePromise = global[symbolPromise].resolve(0);\n                }\n            }\n            if (nativeMicroTaskQueuePromise) {\n                let nativeThen = nativeMicroTaskQueuePromise[symbolThen];\n                if (!nativeThen) {\n                    // native Promise is not patchable, we need to use `then` directly\n                    // issue 1078\n                    nativeThen = nativeMicroTaskQueuePromise['then'];\n                }\n                nativeThen.call(nativeMicroTaskQueuePromise, drainMicroTaskQueue);\n            }\n            else {\n                global[symbolSetTimeout](drainMicroTaskQueue, 0);\n            }\n        }\n        task && _microTaskQueue.push(task);\n    }\n    function drainMicroTaskQueue() {\n        if (!_isDrainingMicrotaskQueue) {\n            _isDrainingMicrotaskQueue = true;\n            while (_microTaskQueue.length) {\n                const queue = _microTaskQueue;\n                _microTaskQueue = [];\n                for (let i = 0; i < queue.length; i++) {\n                    const task = queue[i];\n                    try {\n                        task.zone.runTask(task, null, null);\n                    }\n                    catch (error) {\n                        _api.onUnhandledError(error);\n                    }\n                }\n            }\n            _api.microtaskDrainDone();\n            _isDrainingMicrotaskQueue = false;\n        }\n    }\n    //////////////////////////////////////////////////////\n    //////////////////////////////////////////////////////\n    ///  BOOTSTRAP\n    //////////////////////////////////////////////////////\n    //////////////////////////////////////////////////////\n    const NO_ZONE = { name: 'NO ZONE' };\n    const notScheduled = 'notScheduled', scheduling = 'scheduling', scheduled = 'scheduled', running = 'running', canceling = 'canceling', unknown = 'unknown';\n    const microTask = 'microTask', macroTask = 'macroTask', eventTask = 'eventTask';\n    const patches = {};\n    const _api = {\n        symbol: __symbol__,\n        currentZoneFrame: () => _currentZoneFrame,\n        onUnhandledError: noop,\n        microtaskDrainDone: noop,\n        scheduleMicroTask: scheduleMicroTask,\n        showUncaughtError: () => !Zone[__symbol__('ignoreConsoleErrorUncaughtError')],\n        patchEventTarget: () => [],\n        patchOnProperties: noop,\n        patchMethod: () => noop,\n        bindArguments: () => [],\n        patchThen: () => noop,\n        patchMacroTask: () => noop,\n        patchEventPrototype: () => noop,\n        isIEOrEdge: () => false,\n        getGlobalObjects: () => undefined,\n        ObjectDefineProperty: () => noop,\n        ObjectGetOwnPropertyDescriptor: () => undefined,\n        ObjectCreate: () => undefined,\n        ArraySlice: () => [],\n        patchClass: () => noop,\n        wrapWithCurrentZone: () => noop,\n        filterProperties: () => [],\n        attachOriginToPatched: () => noop,\n        _redefineProperty: () => noop,\n        patchCallbacks: () => noop\n    };\n    let _currentZoneFrame = { parent: null, zone: new Zone(null, null) };\n    let _currentTask = null;\n    let _numberOfNestedTaskFrames = 0;\n    function noop() { }\n    performanceMeasure('Zone', 'Zone');\n    return global['Zone'] = Zone;\n})(typeof window !== 'undefined' && window || typeof self !== 'undefined' && self || __webpack_require__.g);\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Suppress closure compiler errors about unknown 'Zone' variable\n * @fileoverview\n * @suppress {undefinedVars,globalThis,missingRequire}\n */\n/// <reference types=\"node\"/>\n// issue #989, to reduce bundle size, use short name\n/** Object.getOwnPropertyDescriptor */\nconst ObjectGetOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\n/** Object.defineProperty */\nconst ObjectDefineProperty = Object.defineProperty;\n/** Object.getPrototypeOf */\nconst ObjectGetPrototypeOf = Object.getPrototypeOf;\n/** Object.create */\nconst ObjectCreate = Object.create;\n/** Array.prototype.slice */\nconst ArraySlice = Array.prototype.slice;\n/** addEventListener string const */\nconst ADD_EVENT_LISTENER_STR = 'addEventListener';\n/** removeEventListener string const */\nconst REMOVE_EVENT_LISTENER_STR = 'removeEventListener';\n/** zoneSymbol addEventListener */\nconst ZONE_SYMBOL_ADD_EVENT_LISTENER = Zone.__symbol__(ADD_EVENT_LISTENER_STR);\n/** zoneSymbol removeEventListener */\nconst ZONE_SYMBOL_REMOVE_EVENT_LISTENER = Zone.__symbol__(REMOVE_EVENT_LISTENER_STR);\n/** true string const */\nconst TRUE_STR = 'true';\n/** false string const */\nconst FALSE_STR = 'false';\n/** Zone symbol prefix string const. */\nconst ZONE_SYMBOL_PREFIX = Zone.__symbol__('');\nfunction wrapWithCurrentZone(callback, source) {\n    return Zone.current.wrap(callback, source);\n}\nfunction scheduleMacroTaskWithCurrentZone(source, callback, data, customSchedule, customCancel) {\n    return Zone.current.scheduleMacroTask(source, callback, data, customSchedule, customCancel);\n}\nconst zoneSymbol = Zone.__symbol__;\nconst isWindowExists = typeof window !== 'undefined';\nconst internalWindow = isWindowExists ? window : undefined;\nconst _global = isWindowExists && internalWindow || typeof self === 'object' && self || __webpack_require__.g;\nconst REMOVE_ATTRIBUTE = 'removeAttribute';\nconst NULL_ON_PROP_VALUE = [null];\nfunction bindArguments(args, source) {\n    for (let i = args.length - 1; i >= 0; i--) {\n        if (typeof args[i] === 'function') {\n            args[i] = wrapWithCurrentZone(args[i], source + '_' + i);\n        }\n    }\n    return args;\n}\nfunction patchPrototype(prototype, fnNames) {\n    const source = prototype.constructor['name'];\n    for (let i = 0; i < fnNames.length; i++) {\n        const name = fnNames[i];\n        const delegate = prototype[name];\n        if (delegate) {\n            const prototypeDesc = ObjectGetOwnPropertyDescriptor(prototype, name);\n            if (!isPropertyWritable(prototypeDesc)) {\n                continue;\n            }\n            prototype[name] = ((delegate) => {\n                const patched = function () {\n                    return delegate.apply(this, bindArguments(arguments, source + '.' + name));\n                };\n                attachOriginToPatched(patched, delegate);\n                return patched;\n            })(delegate);\n        }\n    }\n}\nfunction isPropertyWritable(propertyDesc) {\n    if (!propertyDesc) {\n        return true;\n    }\n    if (propertyDesc.writable === false) {\n        return false;\n    }\n    return !(typeof propertyDesc.get === 'function' && typeof propertyDesc.set === 'undefined');\n}\nconst isWebWorker = (typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope);\n// Make sure to access `process` through `_global` so that WebPack does not accidentally browserify\n// this code.\nconst isNode = (!('nw' in _global) && typeof _global.process !== 'undefined' &&\n    {}.toString.call(_global.process) === '[object process]');\nconst isBrowser = !isNode && !isWebWorker && !!(isWindowExists && internalWindow['HTMLElement']);\n// we are in electron of nw, so we are both browser and nodejs\n// Make sure to access `process` through `_global` so that WebPack does not accidentally browserify\n// this code.\nconst isMix = typeof _global.process !== 'undefined' &&\n    {}.toString.call(_global.process) === '[object process]' && !isWebWorker &&\n    !!(isWindowExists && internalWindow['HTMLElement']);\nconst zoneSymbolEventNames = {};\nconst wrapFn = function (event) {\n    // https://github.com/angular/zone.js/issues/911, in IE, sometimes\n    // event will be undefined, so we need to use window.event\n    event = event || _global.event;\n    if (!event) {\n        return;\n    }\n    let eventNameSymbol = zoneSymbolEventNames[event.type];\n    if (!eventNameSymbol) {\n        eventNameSymbol = zoneSymbolEventNames[event.type] = zoneSymbol('ON_PROPERTY' + event.type);\n    }\n    const target = this || event.target || _global;\n    const listener = target[eventNameSymbol];\n    let result;\n    if (isBrowser && target === internalWindow && event.type === 'error') {\n        // window.onerror have different signiture\n        // https://developer.mozilla.org/en-US/docs/Web/API/GlobalEventHandlers/onerror#window.onerror\n        // and onerror callback will prevent default when callback return true\n        const errorEvent = event;\n        result = listener &&\n            listener.call(this, errorEvent.message, errorEvent.filename, errorEvent.lineno, errorEvent.colno, errorEvent.error);\n        if (result === true) {\n            event.preventDefault();\n        }\n    }\n    else {\n        result = listener && listener.apply(this, arguments);\n        if (result != undefined && !result) {\n            event.preventDefault();\n        }\n    }\n    return result;\n};\nfunction patchProperty(obj, prop, prototype) {\n    let desc = ObjectGetOwnPropertyDescriptor(obj, prop);\n    if (!desc && prototype) {\n        // when patch window object, use prototype to check prop exist or not\n        const prototypeDesc = ObjectGetOwnPropertyDescriptor(prototype, prop);\n        if (prototypeDesc) {\n            desc = { enumerable: true, configurable: true };\n        }\n    }\n    // if the descriptor not exists or is not configurable\n    // just return\n    if (!desc || !desc.configurable) {\n        return;\n    }\n    const onPropPatchedSymbol = zoneSymbol('on' + prop + 'patched');\n    if (obj.hasOwnProperty(onPropPatchedSymbol) && obj[onPropPatchedSymbol]) {\n        return;\n    }\n    // A property descriptor cannot have getter/setter and be writable\n    // deleting the writable and value properties avoids this error:\n    //\n    // TypeError: property descriptors must not specify a value or be writable when a\n    // getter or setter has been specified\n    delete desc.writable;\n    delete desc.value;\n    const originalDescGet = desc.get;\n    const originalDescSet = desc.set;\n    // substr(2) cuz 'onclick' -> 'click', etc\n    const eventName = prop.substr(2);\n    let eventNameSymbol = zoneSymbolEventNames[eventName];\n    if (!eventNameSymbol) {\n        eventNameSymbol = zoneSymbolEventNames[eventName] = zoneSymbol('ON_PROPERTY' + eventName);\n    }\n    desc.set = function (newValue) {\n        // in some of windows's onproperty callback, this is undefined\n        // so we need to check it\n        let target = this;\n        if (!target && obj === _global) {\n            target = _global;\n        }\n        if (!target) {\n            return;\n        }\n        let previousValue = target[eventNameSymbol];\n        if (previousValue) {\n            target.removeEventListener(eventName, wrapFn);\n        }\n        // issue #978, when onload handler was added before loading zone.js\n        // we should remove it with originalDescSet\n        if (originalDescSet) {\n            originalDescSet.apply(target, NULL_ON_PROP_VALUE);\n        }\n        if (typeof newValue === 'function') {\n            target[eventNameSymbol] = newValue;\n            target.addEventListener(eventName, wrapFn, false);\n        }\n        else {\n            target[eventNameSymbol] = null;\n        }\n    };\n    // The getter would return undefined for unassigned properties but the default value of an\n    // unassigned property is null\n    desc.get = function () {\n        // in some of windows's onproperty callback, this is undefined\n        // so we need to check it\n        let target = this;\n        if (!target && obj === _global) {\n            target = _global;\n        }\n        if (!target) {\n            return null;\n        }\n        const listener = target[eventNameSymbol];\n        if (listener) {\n            return listener;\n        }\n        else if (originalDescGet) {\n            // result will be null when use inline event attribute,\n            // such as <button onclick=\"func();\">OK</button>\n            // because the onclick function is internal raw uncompiled handler\n            // the onclick will be evaluated when first time event was triggered or\n            // the property is accessed, https://github.com/angular/zone.js/issues/525\n            // so we should use original native get to retrieve the handler\n            let value = originalDescGet && originalDescGet.call(this);\n            if (value) {\n                desc.set.call(this, value);\n                if (typeof target[REMOVE_ATTRIBUTE] === 'function') {\n                    target.removeAttribute(prop);\n                }\n                return value;\n            }\n        }\n        return null;\n    };\n    ObjectDefineProperty(obj, prop, desc);\n    obj[onPropPatchedSymbol] = true;\n}\nfunction patchOnProperties(obj, properties, prototype) {\n    if (properties) {\n        for (let i = 0; i < properties.length; i++) {\n            patchProperty(obj, 'on' + properties[i], prototype);\n        }\n    }\n    else {\n        const onProperties = [];\n        for (const prop in obj) {\n            if (prop.substr(0, 2) == 'on') {\n                onProperties.push(prop);\n            }\n        }\n        for (let j = 0; j < onProperties.length; j++) {\n            patchProperty(obj, onProperties[j], prototype);\n        }\n    }\n}\nconst originalInstanceKey = zoneSymbol('originalInstance');\n// wrap some native API on `window`\nfunction patchClass(className) {\n    const OriginalClass = _global[className];\n    if (!OriginalClass)\n        return;\n    // keep original class in global\n    _global[zoneSymbol(className)] = OriginalClass;\n    _global[className] = function () {\n        const a = bindArguments(arguments, className);\n        switch (a.length) {\n            case 0:\n                this[originalInstanceKey] = new OriginalClass();\n                break;\n            case 1:\n                this[originalInstanceKey] = new OriginalClass(a[0]);\n                break;\n            case 2:\n                this[originalInstanceKey] = new OriginalClass(a[0], a[1]);\n                break;\n            case 3:\n                this[originalInstanceKey] = new OriginalClass(a[0], a[1], a[2]);\n                break;\n            case 4:\n                this[originalInstanceKey] = new OriginalClass(a[0], a[1], a[2], a[3]);\n                break;\n            default:\n                throw new Error('Arg list too long.');\n        }\n    };\n    // attach original delegate to patched function\n    attachOriginToPatched(_global[className], OriginalClass);\n    const instance = new OriginalClass(function () { });\n    let prop;\n    for (prop in instance) {\n        // https://bugs.webkit.org/show_bug.cgi?id=44721\n        if (className === 'XMLHttpRequest' && prop === 'responseBlob')\n            continue;\n        (function (prop) {\n            if (typeof instance[prop] === 'function') {\n                _global[className].prototype[prop] = function () {\n                    return this[originalInstanceKey][prop].apply(this[originalInstanceKey], arguments);\n                };\n            }\n            else {\n                ObjectDefineProperty(_global[className].prototype, prop, {\n                    set: function (fn) {\n                        if (typeof fn === 'function') {\n                            this[originalInstanceKey][prop] = wrapWithCurrentZone(fn, className + '.' + prop);\n                            // keep callback in wrapped function so we can\n                            // use it in Function.prototype.toString to return\n                            // the native one.\n                            attachOriginToPatched(this[originalInstanceKey][prop], fn);\n                        }\n                        else {\n                            this[originalInstanceKey][prop] = fn;\n                        }\n                    },\n                    get: function () {\n                        return this[originalInstanceKey][prop];\n                    }\n                });\n            }\n        }(prop));\n    }\n    for (prop in OriginalClass) {\n        if (prop !== 'prototype' && OriginalClass.hasOwnProperty(prop)) {\n            _global[className][prop] = OriginalClass[prop];\n        }\n    }\n}\nfunction patchMethod(target, name, patchFn) {\n    let proto = target;\n    while (proto && !proto.hasOwnProperty(name)) {\n        proto = ObjectGetPrototypeOf(proto);\n    }\n    if (!proto && target[name]) {\n        // somehow we did not find it, but we can see it. This happens on IE for Window properties.\n        proto = target;\n    }\n    const delegateName = zoneSymbol(name);\n    let delegate = null;\n    if (proto && !(delegate = proto[delegateName])) {\n        delegate = proto[delegateName] = proto[name];\n        // check whether proto[name] is writable\n        // some property is readonly in safari, such as HtmlCanvasElement.prototype.toBlob\n        const desc = proto && ObjectGetOwnPropertyDescriptor(proto, name);\n        if (isPropertyWritable(desc)) {\n            const patchDelegate = patchFn(delegate, delegateName, name);\n            proto[name] = function () {\n                return patchDelegate(this, arguments);\n            };\n            attachOriginToPatched(proto[name], delegate);\n        }\n    }\n    return delegate;\n}\n// TODO: @JiaLiPassion, support cancel task later if necessary\nfunction patchMacroTask(obj, funcName, metaCreator) {\n    let setNative = null;\n    function scheduleTask(task) {\n        const data = task.data;\n        data.args[data.cbIdx] = function () {\n            task.invoke.apply(this, arguments);\n        };\n        setNative.apply(data.target, data.args);\n        return task;\n    }\n    setNative = patchMethod(obj, funcName, (delegate) => function (self, args) {\n        const meta = metaCreator(self, args);\n        if (meta.cbIdx >= 0 && typeof args[meta.cbIdx] === 'function') {\n            return scheduleMacroTaskWithCurrentZone(meta.name, args[meta.cbIdx], meta, scheduleTask);\n        }\n        else {\n            // cause an error by calling it directly.\n            return delegate.apply(self, args);\n        }\n    });\n}\nfunction attachOriginToPatched(patched, original) {\n    patched[zoneSymbol('OriginalDelegate')] = original;\n}\nlet isDetectedIEOrEdge = false;\nlet ieOrEdge = false;\nfunction isIE() {\n    try {\n        const ua = internalWindow.navigator.userAgent;\n        if (ua.indexOf('MSIE ') !== -1 || ua.indexOf('Trident/') !== -1) {\n            return true;\n        }\n    }\n    catch (error) {\n    }\n    return false;\n}\nfunction isIEOrEdge() {\n    if (isDetectedIEOrEdge) {\n        return ieOrEdge;\n    }\n    isDetectedIEOrEdge = true;\n    try {\n        const ua = internalWindow.navigator.userAgent;\n        if (ua.indexOf('MSIE ') !== -1 || ua.indexOf('Trident/') !== -1 || ua.indexOf('Edge/') !== -1) {\n            ieOrEdge = true;\n        }\n    }\n    catch (error) {\n    }\n    return ieOrEdge;\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nZone.__load_patch('ZoneAwarePromise', (global, Zone, api) => {\n    const ObjectGetOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\n    const ObjectDefineProperty = Object.defineProperty;\n    function readableObjectToString(obj) {\n        if (obj && obj.toString === Object.prototype.toString) {\n            const className = obj.constructor && obj.constructor.name;\n            return (className ? className : '') + ': ' + JSON.stringify(obj);\n        }\n        return obj ? obj.toString() : Object.prototype.toString.call(obj);\n    }\n    const __symbol__ = api.symbol;\n    const _uncaughtPromiseErrors = [];\n    const isDisableWrappingUncaughtPromiseRejection = global[__symbol__('DISABLE_WRAPPING_UNCAUGHT_PROMISE_REJECTION')] === true;\n    const symbolPromise = __symbol__('Promise');\n    const symbolThen = __symbol__('then');\n    const creationTrace = '__creationTrace__';\n    api.onUnhandledError = (e) => {\n        if (api.showUncaughtError()) {\n            const rejection = e && e.rejection;\n            if (rejection) {\n                console.error('Unhandled Promise rejection:', rejection instanceof Error ? rejection.message : rejection, '; Zone:', e.zone.name, '; Task:', e.task && e.task.source, '; Value:', rejection, rejection instanceof Error ? rejection.stack : undefined);\n            }\n            else {\n                console.error(e);\n            }\n        }\n    };\n    api.microtaskDrainDone = () => {\n        while (_uncaughtPromiseErrors.length) {\n            const uncaughtPromiseError = _uncaughtPromiseErrors.shift();\n            try {\n                uncaughtPromiseError.zone.runGuarded(() => {\n                    if (uncaughtPromiseError.throwOriginal) {\n                        throw uncaughtPromiseError.rejection;\n                    }\n                    throw uncaughtPromiseError;\n                });\n            }\n            catch (error) {\n                handleUnhandledRejection(error);\n            }\n        }\n    };\n    const UNHANDLED_PROMISE_REJECTION_HANDLER_SYMBOL = __symbol__('unhandledPromiseRejectionHandler');\n    function handleUnhandledRejection(e) {\n        api.onUnhandledError(e);\n        try {\n            const handler = Zone[UNHANDLED_PROMISE_REJECTION_HANDLER_SYMBOL];\n            if (typeof handler === 'function') {\n                handler.call(this, e);\n            }\n        }\n        catch (err) {\n        }\n    }\n    function isThenable(value) {\n        return value && value.then;\n    }\n    function forwardResolution(value) {\n        return value;\n    }\n    function forwardRejection(rejection) {\n        return ZoneAwarePromise.reject(rejection);\n    }\n    const symbolState = __symbol__('state');\n    const symbolValue = __symbol__('value');\n    const symbolFinally = __symbol__('finally');\n    const symbolParentPromiseValue = __symbol__('parentPromiseValue');\n    const symbolParentPromiseState = __symbol__('parentPromiseState');\n    const source = 'Promise.then';\n    const UNRESOLVED = null;\n    const RESOLVED = true;\n    const REJECTED = false;\n    const REJECTED_NO_CATCH = 0;\n    function makeResolver(promise, state) {\n        return (v) => {\n            try {\n                resolvePromise(promise, state, v);\n            }\n            catch (err) {\n                resolvePromise(promise, false, err);\n            }\n            // Do not return value or you will break the Promise spec.\n        };\n    }\n    const once = function () {\n        let wasCalled = false;\n        return function wrapper(wrappedFunction) {\n            return function () {\n                if (wasCalled) {\n                    return;\n                }\n                wasCalled = true;\n                wrappedFunction.apply(null, arguments);\n            };\n        };\n    };\n    const TYPE_ERROR = 'Promise resolved with itself';\n    const CURRENT_TASK_TRACE_SYMBOL = __symbol__('currentTaskTrace');\n    // Promise Resolution\n    function resolvePromise(promise, state, value) {\n        const onceWrapper = once();\n        if (promise === value) {\n            throw new TypeError(TYPE_ERROR);\n        }\n        if (promise[symbolState] === UNRESOLVED) {\n            // should only get value.then once based on promise spec.\n            let then = null;\n            try {\n                if (typeof value === 'object' || typeof value === 'function') {\n                    then = value && value.then;\n                }\n            }\n            catch (err) {\n                onceWrapper(() => {\n                    resolvePromise(promise, false, err);\n                })();\n                return promise;\n            }\n            // if (value instanceof ZoneAwarePromise) {\n            if (state !== REJECTED && value instanceof ZoneAwarePromise &&\n                value.hasOwnProperty(symbolState) && value.hasOwnProperty(symbolValue) &&\n                value[symbolState] !== UNRESOLVED) {\n                clearRejectedNoCatch(value);\n                resolvePromise(promise, value[symbolState], value[symbolValue]);\n            }\n            else if (state !== REJECTED && typeof then === 'function') {\n                try {\n                    then.call(value, onceWrapper(makeResolver(promise, state)), onceWrapper(makeResolver(promise, false)));\n                }\n                catch (err) {\n                    onceWrapper(() => {\n                        resolvePromise(promise, false, err);\n                    })();\n                }\n            }\n            else {\n                promise[symbolState] = state;\n                const queue = promise[symbolValue];\n                promise[symbolValue] = value;\n                if (promise[symbolFinally] === symbolFinally) {\n                    // the promise is generated by Promise.prototype.finally\n                    if (state === RESOLVED) {\n                        // the state is resolved, should ignore the value\n                        // and use parent promise value\n                        promise[symbolState] = promise[symbolParentPromiseState];\n                        promise[symbolValue] = promise[symbolParentPromiseValue];\n                    }\n                }\n                // record task information in value when error occurs, so we can\n                // do some additional work such as render longStackTrace\n                if (state === REJECTED && value instanceof Error) {\n                    // check if longStackTraceZone is here\n                    const trace = Zone.currentTask && Zone.currentTask.data &&\n                        Zone.currentTask.data[creationTrace];\n                    if (trace) {\n                        // only keep the long stack trace into error when in longStackTraceZone\n                        ObjectDefineProperty(value, CURRENT_TASK_TRACE_SYMBOL, { configurable: true, enumerable: false, writable: true, value: trace });\n                    }\n                }\n                for (let i = 0; i < queue.length;) {\n                    scheduleResolveOrReject(promise, queue[i++], queue[i++], queue[i++], queue[i++]);\n                }\n                if (queue.length == 0 && state == REJECTED) {\n                    promise[symbolState] = REJECTED_NO_CATCH;\n                    let uncaughtPromiseError = value;\n                    try {\n                        // Here we throws a new Error to print more readable error log\n                        // and if the value is not an error, zone.js builds an `Error`\n                        // Object here to attach the stack information.\n                        throw new Error('Uncaught (in promise): ' + readableObjectToString(value) +\n                            (value && value.stack ? '\\n' + value.stack : ''));\n                    }\n                    catch (err) {\n                        uncaughtPromiseError = err;\n                    }\n                    if (isDisableWrappingUncaughtPromiseRejection) {\n                        // If disable wrapping uncaught promise reject\n                        // use the value instead of wrapping it.\n                        uncaughtPromiseError.throwOriginal = true;\n                    }\n                    uncaughtPromiseError.rejection = value;\n                    uncaughtPromiseError.promise = promise;\n                    uncaughtPromiseError.zone = Zone.current;\n                    uncaughtPromiseError.task = Zone.currentTask;\n                    _uncaughtPromiseErrors.push(uncaughtPromiseError);\n                    api.scheduleMicroTask(); // to make sure that it is running\n                }\n            }\n        }\n        // Resolving an already resolved promise is a noop.\n        return promise;\n    }\n    const REJECTION_HANDLED_HANDLER = __symbol__('rejectionHandledHandler');\n    function clearRejectedNoCatch(promise) {\n        if (promise[symbolState] === REJECTED_NO_CATCH) {\n            // if the promise is rejected no catch status\n            // and queue.length > 0, means there is a error handler\n            // here to handle the rejected promise, we should trigger\n            // windows.rejectionhandled eventHandler or nodejs rejectionHandled\n            // eventHandler\n            try {\n                const handler = Zone[REJECTION_HANDLED_HANDLER];\n                if (handler && typeof handler === 'function') {\n                    handler.call(this, { rejection: promise[symbolValue], promise: promise });\n                }\n            }\n            catch (err) {\n            }\n            promise[symbolState] = REJECTED;\n            for (let i = 0; i < _uncaughtPromiseErrors.length; i++) {\n                if (promise === _uncaughtPromiseErrors[i].promise) {\n                    _uncaughtPromiseErrors.splice(i, 1);\n                }\n            }\n        }\n    }\n    function scheduleResolveOrReject(promise, zone, chainPromise, onFulfilled, onRejected) {\n        clearRejectedNoCatch(promise);\n        const promiseState = promise[symbolState];\n        const delegate = promiseState ?\n            (typeof onFulfilled === 'function') ? onFulfilled : forwardResolution :\n            (typeof onRejected === 'function') ? onRejected : forwardRejection;\n        zone.scheduleMicroTask(source, () => {\n            try {\n                const parentPromiseValue = promise[symbolValue];\n                const isFinallyPromise = !!chainPromise && symbolFinally === chainPromise[symbolFinally];\n                if (isFinallyPromise) {\n                    // if the promise is generated from finally call, keep parent promise's state and value\n                    chainPromise[symbolParentPromiseValue] = parentPromiseValue;\n                    chainPromise[symbolParentPromiseState] = promiseState;\n                }\n                // should not pass value to finally callback\n                const value = zone.run(delegate, undefined, isFinallyPromise && delegate !== forwardRejection && delegate !== forwardResolution ?\n                    [] :\n                    [parentPromiseValue]);\n                resolvePromise(chainPromise, true, value);\n            }\n            catch (error) {\n                // if error occurs, should always return this error\n                resolvePromise(chainPromise, false, error);\n            }\n        }, chainPromise);\n    }\n    const ZONE_AWARE_PROMISE_TO_STRING = 'function ZoneAwarePromise() { [native code] }';\n    const noop = function () { };\n    class ZoneAwarePromise {\n        static toString() {\n            return ZONE_AWARE_PROMISE_TO_STRING;\n        }\n        static resolve(value) {\n            return resolvePromise(new this(null), RESOLVED, value);\n        }\n        static reject(error) {\n            return resolvePromise(new this(null), REJECTED, error);\n        }\n        static race(values) {\n            let resolve;\n            let reject;\n            let promise = new this((res, rej) => {\n                resolve = res;\n                reject = rej;\n            });\n            function onResolve(value) {\n                resolve(value);\n            }\n            function onReject(error) {\n                reject(error);\n            }\n            for (let value of values) {\n                if (!isThenable(value)) {\n                    value = this.resolve(value);\n                }\n                value.then(onResolve, onReject);\n            }\n            return promise;\n        }\n        static all(values) {\n            return ZoneAwarePromise.allWithCallback(values);\n        }\n        static allSettled(values) {\n            const P = this && this.prototype instanceof ZoneAwarePromise ? this : ZoneAwarePromise;\n            return P.allWithCallback(values, {\n                thenCallback: (value) => ({ status: 'fulfilled', value }),\n                errorCallback: (err) => ({ status: 'rejected', reason: err })\n            });\n        }\n        static allWithCallback(values, callback) {\n            let resolve;\n            let reject;\n            let promise = new this((res, rej) => {\n                resolve = res;\n                reject = rej;\n            });\n            // Start at 2 to prevent prematurely resolving if .then is called immediately.\n            let unresolvedCount = 2;\n            let valueIndex = 0;\n            const resolvedValues = [];\n            for (let value of values) {\n                if (!isThenable(value)) {\n                    value = this.resolve(value);\n                }\n                const curValueIndex = valueIndex;\n                try {\n                    value.then((value) => {\n                        resolvedValues[curValueIndex] = callback ? callback.thenCallback(value) : value;\n                        unresolvedCount--;\n                        if (unresolvedCount === 0) {\n                            resolve(resolvedValues);\n                        }\n                    }, (err) => {\n                        if (!callback) {\n                            reject(err);\n                        }\n                        else {\n                            resolvedValues[curValueIndex] = callback.errorCallback(err);\n                            unresolvedCount--;\n                            if (unresolvedCount === 0) {\n                                resolve(resolvedValues);\n                            }\n                        }\n                    });\n                }\n                catch (thenErr) {\n                    reject(thenErr);\n                }\n                unresolvedCount++;\n                valueIndex++;\n            }\n            // Make the unresolvedCount zero-based again.\n            unresolvedCount -= 2;\n            if (unresolvedCount === 0) {\n                resolve(resolvedValues);\n            }\n            return promise;\n        }\n        constructor(executor) {\n            const promise = this;\n            if (!(promise instanceof ZoneAwarePromise)) {\n                throw new Error('Must be an instanceof Promise.');\n            }\n            promise[symbolState] = UNRESOLVED;\n            promise[symbolValue] = []; // queue;\n            try {\n                executor && executor(makeResolver(promise, RESOLVED), makeResolver(promise, REJECTED));\n            }\n            catch (error) {\n                resolvePromise(promise, false, error);\n            }\n        }\n        get [Symbol.toStringTag]() {\n            return 'Promise';\n        }\n        get [Symbol.species]() {\n            return ZoneAwarePromise;\n        }\n        then(onFulfilled, onRejected) {\n            let C = this.constructor[Symbol.species];\n            if (!C || typeof C !== 'function') {\n                C = this.constructor || ZoneAwarePromise;\n            }\n            const chainPromise = new C(noop);\n            const zone = Zone.current;\n            if (this[symbolState] == UNRESOLVED) {\n                this[symbolValue].push(zone, chainPromise, onFulfilled, onRejected);\n            }\n            else {\n                scheduleResolveOrReject(this, zone, chainPromise, onFulfilled, onRejected);\n            }\n            return chainPromise;\n        }\n        catch(onRejected) {\n            return this.then(null, onRejected);\n        }\n        finally(onFinally) {\n            let C = this.constructor[Symbol.species];\n            if (!C || typeof C !== 'function') {\n                C = ZoneAwarePromise;\n            }\n            const chainPromise = new C(noop);\n            chainPromise[symbolFinally] = symbolFinally;\n            const zone = Zone.current;\n            if (this[symbolState] == UNRESOLVED) {\n                this[symbolValue].push(zone, chainPromise, onFinally, onFinally);\n            }\n            else {\n                scheduleResolveOrReject(this, zone, chainPromise, onFinally, onFinally);\n            }\n            return chainPromise;\n        }\n    }\n    // Protect against aggressive optimizers dropping seemingly unused properties.\n    // E.g. Closure Compiler in advanced mode.\n    ZoneAwarePromise['resolve'] = ZoneAwarePromise.resolve;\n    ZoneAwarePromise['reject'] = ZoneAwarePromise.reject;\n    ZoneAwarePromise['race'] = ZoneAwarePromise.race;\n    ZoneAwarePromise['all'] = ZoneAwarePromise.all;\n    const NativePromise = global[symbolPromise] = global['Promise'];\n    global['Promise'] = ZoneAwarePromise;\n    const symbolThenPatched = __symbol__('thenPatched');\n    function patchThen(Ctor) {\n        const proto = Ctor.prototype;\n        const prop = ObjectGetOwnPropertyDescriptor(proto, 'then');\n        if (prop && (prop.writable === false || !prop.configurable)) {\n            // check Ctor.prototype.then propertyDescriptor is writable or not\n            // in meteor env, writable is false, we should ignore such case\n            return;\n        }\n        const originalThen = proto.then;\n        // Keep a reference to the original method.\n        proto[symbolThen] = originalThen;\n        Ctor.prototype.then = function (onResolve, onReject) {\n            const wrapped = new ZoneAwarePromise((resolve, reject) => {\n                originalThen.call(this, resolve, reject);\n            });\n            return wrapped.then(onResolve, onReject);\n        };\n        Ctor[symbolThenPatched] = true;\n    }\n    api.patchThen = patchThen;\n    function zoneify(fn) {\n        return function (self, args) {\n            let resultPromise = fn.apply(self, args);\n            if (resultPromise instanceof ZoneAwarePromise) {\n                return resultPromise;\n            }\n            let ctor = resultPromise.constructor;\n            if (!ctor[symbolThenPatched]) {\n                patchThen(ctor);\n            }\n            return resultPromise;\n        };\n    }\n    if (NativePromise) {\n        patchThen(NativePromise);\n        patchMethod(global, 'fetch', delegate => zoneify(delegate));\n    }\n    // This is not part of public API, but it is useful for tests, so we expose it.\n    Promise[Zone.__symbol__('uncaughtPromiseErrors')] = _uncaughtPromiseErrors;\n    return ZoneAwarePromise;\n});\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n// override Function.prototype.toString to make zone.js patched function\n// look like native function\nZone.__load_patch('toString', (global) => {\n    // patch Func.prototype.toString to let them look like native\n    const originalFunctionToString = Function.prototype.toString;\n    const ORIGINAL_DELEGATE_SYMBOL = zoneSymbol('OriginalDelegate');\n    const PROMISE_SYMBOL = zoneSymbol('Promise');\n    const ERROR_SYMBOL = zoneSymbol('Error');\n    const newFunctionToString = function toString() {\n        if (typeof this === 'function') {\n            const originalDelegate = this[ORIGINAL_DELEGATE_SYMBOL];\n            if (originalDelegate) {\n                if (typeof originalDelegate === 'function') {\n                    return originalFunctionToString.call(originalDelegate);\n                }\n                else {\n                    return Object.prototype.toString.call(originalDelegate);\n                }\n            }\n            if (this === Promise) {\n                const nativePromise = global[PROMISE_SYMBOL];\n                if (nativePromise) {\n                    return originalFunctionToString.call(nativePromise);\n                }\n            }\n            if (this === Error) {\n                const nativeError = global[ERROR_SYMBOL];\n                if (nativeError) {\n                    return originalFunctionToString.call(nativeError);\n                }\n            }\n        }\n        return originalFunctionToString.call(this);\n    };\n    newFunctionToString[ORIGINAL_DELEGATE_SYMBOL] = originalFunctionToString;\n    Function.prototype.toString = newFunctionToString;\n    // patch Object.prototype.toString to let them look like native\n    const originalObjectToString = Object.prototype.toString;\n    const PROMISE_OBJECT_TO_STRING = '[object Promise]';\n    Object.prototype.toString = function () {\n        if (typeof Promise === 'function' && this instanceof Promise) {\n            return PROMISE_OBJECT_TO_STRING;\n        }\n        return originalObjectToString.call(this);\n    };\n});\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nlet passiveSupported = false;\nif (typeof window !== 'undefined') {\n    try {\n        const options = Object.defineProperty({}, 'passive', {\n            get: function () {\n                passiveSupported = true;\n            }\n        });\n        window.addEventListener('test', options, options);\n        window.removeEventListener('test', options, options);\n    }\n    catch (err) {\n        passiveSupported = false;\n    }\n}\n// an identifier to tell ZoneTask do not create a new invoke closure\nconst OPTIMIZED_ZONE_EVENT_TASK_DATA = {\n    useG: true\n};\nconst zoneSymbolEventNames$1 = {};\nconst globalSources = {};\nconst EVENT_NAME_SYMBOL_REGX = new RegExp('^' + ZONE_SYMBOL_PREFIX + '(\\\\w+)(true|false)$');\nconst IMMEDIATE_PROPAGATION_SYMBOL = zoneSymbol('propagationStopped');\nfunction prepareEventNames(eventName, eventNameToString) {\n    const falseEventName = (eventNameToString ? eventNameToString(eventName) : eventName) + FALSE_STR;\n    const trueEventName = (eventNameToString ? eventNameToString(eventName) : eventName) + TRUE_STR;\n    const symbol = ZONE_SYMBOL_PREFIX + falseEventName;\n    const symbolCapture = ZONE_SYMBOL_PREFIX + trueEventName;\n    zoneSymbolEventNames$1[eventName] = {};\n    zoneSymbolEventNames$1[eventName][FALSE_STR] = symbol;\n    zoneSymbolEventNames$1[eventName][TRUE_STR] = symbolCapture;\n}\nfunction patchEventTarget(_global, apis, patchOptions) {\n    const ADD_EVENT_LISTENER = (patchOptions && patchOptions.add) || ADD_EVENT_LISTENER_STR;\n    const REMOVE_EVENT_LISTENER = (patchOptions && patchOptions.rm) || REMOVE_EVENT_LISTENER_STR;\n    const LISTENERS_EVENT_LISTENER = (patchOptions && patchOptions.listeners) || 'eventListeners';\n    const REMOVE_ALL_LISTENERS_EVENT_LISTENER = (patchOptions && patchOptions.rmAll) || 'removeAllListeners';\n    const zoneSymbolAddEventListener = zoneSymbol(ADD_EVENT_LISTENER);\n    const ADD_EVENT_LISTENER_SOURCE = '.' + ADD_EVENT_LISTENER + ':';\n    const PREPEND_EVENT_LISTENER = 'prependListener';\n    const PREPEND_EVENT_LISTENER_SOURCE = '.' + PREPEND_EVENT_LISTENER + ':';\n    const invokeTask = function (task, target, event) {\n        // for better performance, check isRemoved which is set\n        // by removeEventListener\n        if (task.isRemoved) {\n            return;\n        }\n        const delegate = task.callback;\n        if (typeof delegate === 'object' && delegate.handleEvent) {\n            // create the bind version of handleEvent when invoke\n            task.callback = (event) => delegate.handleEvent(event);\n            task.originalDelegate = delegate;\n        }\n        // invoke static task.invoke\n        task.invoke(task, target, [event]);\n        const options = task.options;\n        if (options && typeof options === 'object' && options.once) {\n            // if options.once is true, after invoke once remove listener here\n            // only browser need to do this, nodejs eventEmitter will cal removeListener\n            // inside EventEmitter.once\n            const delegate = task.originalDelegate ? task.originalDelegate : task.callback;\n            target[REMOVE_EVENT_LISTENER].call(target, event.type, delegate, options);\n        }\n    };\n    // global shared zoneAwareCallback to handle all event callback with capture = false\n    const globalZoneAwareCallback = function (event) {\n        // https://github.com/angular/zone.js/issues/911, in IE, sometimes\n        // event will be undefined, so we need to use window.event\n        event = event || _global.event;\n        if (!event) {\n            return;\n        }\n        // event.target is needed for Samsung TV and SourceBuffer\n        // || global is needed https://github.com/angular/zone.js/issues/190\n        const target = this || event.target || _global;\n        const tasks = target[zoneSymbolEventNames$1[event.type][FALSE_STR]];\n        if (tasks) {\n            // invoke all tasks which attached to current target with given event.type and capture = false\n            // for performance concern, if task.length === 1, just invoke\n            if (tasks.length === 1) {\n                invokeTask(tasks[0], target, event);\n            }\n            else {\n                // https://github.com/angular/zone.js/issues/836\n                // copy the tasks array before invoke, to avoid\n                // the callback will remove itself or other listener\n                const copyTasks = tasks.slice();\n                for (let i = 0; i < copyTasks.length; i++) {\n                    if (event && event[IMMEDIATE_PROPAGATION_SYMBOL] === true) {\n                        break;\n                    }\n                    invokeTask(copyTasks[i], target, event);\n                }\n            }\n        }\n    };\n    // global shared zoneAwareCallback to handle all event callback with capture = true\n    const globalZoneAwareCaptureCallback = function (event) {\n        // https://github.com/angular/zone.js/issues/911, in IE, sometimes\n        // event will be undefined, so we need to use window.event\n        event = event || _global.event;\n        if (!event) {\n            return;\n        }\n        // event.target is needed for Samsung TV and SourceBuffer\n        // || global is needed https://github.com/angular/zone.js/issues/190\n        const target = this || event.target || _global;\n        const tasks = target[zoneSymbolEventNames$1[event.type][TRUE_STR]];\n        if (tasks) {\n            // invoke all tasks which attached to current target with given event.type and capture = false\n            // for performance concern, if task.length === 1, just invoke\n            if (tasks.length === 1) {\n                invokeTask(tasks[0], target, event);\n            }\n            else {\n                // https://github.com/angular/zone.js/issues/836\n                // copy the tasks array before invoke, to avoid\n                // the callback will remove itself or other listener\n                const copyTasks = tasks.slice();\n                for (let i = 0; i < copyTasks.length; i++) {\n                    if (event && event[IMMEDIATE_PROPAGATION_SYMBOL] === true) {\n                        break;\n                    }\n                    invokeTask(copyTasks[i], target, event);\n                }\n            }\n        }\n    };\n    function patchEventTargetMethods(obj, patchOptions) {\n        if (!obj) {\n            return false;\n        }\n        let useGlobalCallback = true;\n        if (patchOptions && patchOptions.useG !== undefined) {\n            useGlobalCallback = patchOptions.useG;\n        }\n        const validateHandler = patchOptions && patchOptions.vh;\n        let checkDuplicate = true;\n        if (patchOptions && patchOptions.chkDup !== undefined) {\n            checkDuplicate = patchOptions.chkDup;\n        }\n        let returnTarget = false;\n        if (patchOptions && patchOptions.rt !== undefined) {\n            returnTarget = patchOptions.rt;\n        }\n        let proto = obj;\n        while (proto && !proto.hasOwnProperty(ADD_EVENT_LISTENER)) {\n            proto = ObjectGetPrototypeOf(proto);\n        }\n        if (!proto && obj[ADD_EVENT_LISTENER]) {\n            // somehow we did not find it, but we can see it. This happens on IE for Window properties.\n            proto = obj;\n        }\n        if (!proto) {\n            return false;\n        }\n        if (proto[zoneSymbolAddEventListener]) {\n            return false;\n        }\n        const eventNameToString = patchOptions && patchOptions.eventNameToString;\n        // a shared global taskData to pass data for scheduleEventTask\n        // so we do not need to create a new object just for pass some data\n        const taskData = {};\n        const nativeAddEventListener = proto[zoneSymbolAddEventListener] = proto[ADD_EVENT_LISTENER];\n        const nativeRemoveEventListener = proto[zoneSymbol(REMOVE_EVENT_LISTENER)] =\n            proto[REMOVE_EVENT_LISTENER];\n        const nativeListeners = proto[zoneSymbol(LISTENERS_EVENT_LISTENER)] =\n            proto[LISTENERS_EVENT_LISTENER];\n        const nativeRemoveAllListeners = proto[zoneSymbol(REMOVE_ALL_LISTENERS_EVENT_LISTENER)] =\n            proto[REMOVE_ALL_LISTENERS_EVENT_LISTENER];\n        let nativePrependEventListener;\n        if (patchOptions && patchOptions.prepend) {\n            nativePrependEventListener = proto[zoneSymbol(patchOptions.prepend)] =\n                proto[patchOptions.prepend];\n        }\n        /**\n         * This util function will build an option object with passive option\n         * to handle all possible input from the user.\n         */\n        function buildEventListenerOptions(options, passive) {\n            if (!passiveSupported && typeof options === 'object' && options) {\n                // doesn't support passive but user want to pass an object as options.\n                // this will not work on some old browser, so we just pass a boolean\n                // as useCapture parameter\n                return !!options.capture;\n            }\n            if (!passiveSupported || !passive) {\n                return options;\n            }\n            if (typeof options === 'boolean') {\n                return { capture: options, passive: true };\n            }\n            if (!options) {\n                return { passive: true };\n            }\n            if (typeof options === 'object' && options.passive !== false) {\n                return Object.assign(Object.assign({}, options), { passive: true });\n            }\n            return options;\n        }\n        const customScheduleGlobal = function (task) {\n            // if there is already a task for the eventName + capture,\n            // just return, because we use the shared globalZoneAwareCallback here.\n            if (taskData.isExisting) {\n                return;\n            }\n            return nativeAddEventListener.call(taskData.target, taskData.eventName, taskData.capture ? globalZoneAwareCaptureCallback : globalZoneAwareCallback, taskData.options);\n        };\n        const customCancelGlobal = function (task) {\n            // if task is not marked as isRemoved, this call is directly\n            // from Zone.prototype.cancelTask, we should remove the task\n            // from tasksList of target first\n            if (!task.isRemoved) {\n                const symbolEventNames = zoneSymbolEventNames$1[task.eventName];\n                let symbolEventName;\n                if (symbolEventNames) {\n                    symbolEventName = symbolEventNames[task.capture ? TRUE_STR : FALSE_STR];\n                }\n                const existingTasks = symbolEventName && task.target[symbolEventName];\n                if (existingTasks) {\n                    for (let i = 0; i < existingTasks.length; i++) {\n                        const existingTask = existingTasks[i];\n                        if (existingTask === task) {\n                            existingTasks.splice(i, 1);\n                            // set isRemoved to data for faster invokeTask check\n                            task.isRemoved = true;\n                            if (existingTasks.length === 0) {\n                                // all tasks for the eventName + capture have gone,\n                                // remove globalZoneAwareCallback and remove the task cache from target\n                                task.allRemoved = true;\n                                task.target[symbolEventName] = null;\n                            }\n                            break;\n                        }\n                    }\n                }\n            }\n            // if all tasks for the eventName + capture have gone,\n            // we will really remove the global event callback,\n            // if not, return\n            if (!task.allRemoved) {\n                return;\n            }\n            return nativeRemoveEventListener.call(task.target, task.eventName, task.capture ? globalZoneAwareCaptureCallback : globalZoneAwareCallback, task.options);\n        };\n        const customScheduleNonGlobal = function (task) {\n            return nativeAddEventListener.call(taskData.target, taskData.eventName, task.invoke, taskData.options);\n        };\n        const customSchedulePrepend = function (task) {\n            return nativePrependEventListener.call(taskData.target, taskData.eventName, task.invoke, taskData.options);\n        };\n        const customCancelNonGlobal = function (task) {\n            return nativeRemoveEventListener.call(task.target, task.eventName, task.invoke, task.options);\n        };\n        const customSchedule = useGlobalCallback ? customScheduleGlobal : customScheduleNonGlobal;\n        const customCancel = useGlobalCallback ? customCancelGlobal : customCancelNonGlobal;\n        const compareTaskCallbackVsDelegate = function (task, delegate) {\n            const typeOfDelegate = typeof delegate;\n            return (typeOfDelegate === 'function' && task.callback === delegate) ||\n                (typeOfDelegate === 'object' && task.originalDelegate === delegate);\n        };\n        const compare = (patchOptions && patchOptions.diff) ? patchOptions.diff : compareTaskCallbackVsDelegate;\n        const unpatchedEvents = Zone[zoneSymbol('UNPATCHED_EVENTS')];\n        const passiveEvents = _global[zoneSymbol('PASSIVE_EVENTS')];\n        const makeAddListener = function (nativeListener, addSource, customScheduleFn, customCancelFn, returnTarget = false, prepend = false) {\n            return function () {\n                const target = this || _global;\n                let eventName = arguments[0];\n                if (patchOptions && patchOptions.transferEventName) {\n                    eventName = patchOptions.transferEventName(eventName);\n                }\n                let delegate = arguments[1];\n                if (!delegate) {\n                    return nativeListener.apply(this, arguments);\n                }\n                if (isNode && eventName === 'uncaughtException') {\n                    // don't patch uncaughtException of nodejs to prevent endless loop\n                    return nativeListener.apply(this, arguments);\n                }\n                // don't create the bind delegate function for handleEvent\n                // case here to improve addEventListener performance\n                // we will create the bind delegate when invoke\n                let isHandleEvent = false;\n                if (typeof delegate !== 'function') {\n                    if (!delegate.handleEvent) {\n                        return nativeListener.apply(this, arguments);\n                    }\n                    isHandleEvent = true;\n                }\n                if (validateHandler && !validateHandler(nativeListener, delegate, target, arguments)) {\n                    return;\n                }\n                const passive = passiveSupported && !!passiveEvents && passiveEvents.indexOf(eventName) !== -1;\n                const options = buildEventListenerOptions(arguments[2], passive);\n                if (unpatchedEvents) {\n                    // check upatched list\n                    for (let i = 0; i < unpatchedEvents.length; i++) {\n                        if (eventName === unpatchedEvents[i]) {\n                            if (passive) {\n                                return nativeListener.call(target, eventName, delegate, options);\n                            }\n                            else {\n                                return nativeListener.apply(this, arguments);\n                            }\n                        }\n                    }\n                }\n                const capture = !options ? false : typeof options === 'boolean' ? true : options.capture;\n                const once = options && typeof options === 'object' ? options.once : false;\n                const zone = Zone.current;\n                let symbolEventNames = zoneSymbolEventNames$1[eventName];\n                if (!symbolEventNames) {\n                    prepareEventNames(eventName, eventNameToString);\n                    symbolEventNames = zoneSymbolEventNames$1[eventName];\n                }\n                const symbolEventName = symbolEventNames[capture ? TRUE_STR : FALSE_STR];\n                let existingTasks = target[symbolEventName];\n                let isExisting = false;\n                if (existingTasks) {\n                    // already have task registered\n                    isExisting = true;\n                    if (checkDuplicate) {\n                        for (let i = 0; i < existingTasks.length; i++) {\n                            if (compare(existingTasks[i], delegate)) {\n                                // same callback, same capture, same event name, just return\n                                return;\n                            }\n                        }\n                    }\n                }\n                else {\n                    existingTasks = target[symbolEventName] = [];\n                }\n                let source;\n                const constructorName = target.constructor['name'];\n                const targetSource = globalSources[constructorName];\n                if (targetSource) {\n                    source = targetSource[eventName];\n                }\n                if (!source) {\n                    source = constructorName + addSource +\n                        (eventNameToString ? eventNameToString(eventName) : eventName);\n                }\n                // do not create a new object as task.data to pass those things\n                // just use the global shared one\n                taskData.options = options;\n                if (once) {\n                    // if addEventListener with once options, we don't pass it to\n                    // native addEventListener, instead we keep the once setting\n                    // and handle ourselves.\n                    taskData.options.once = false;\n                }\n                taskData.target = target;\n                taskData.capture = capture;\n                taskData.eventName = eventName;\n                taskData.isExisting = isExisting;\n                const data = useGlobalCallback ? OPTIMIZED_ZONE_EVENT_TASK_DATA : undefined;\n                // keep taskData into data to allow onScheduleEventTask to access the task information\n                if (data) {\n                    data.taskData = taskData;\n                }\n                const task = zone.scheduleEventTask(source, delegate, data, customScheduleFn, customCancelFn);\n                // should clear taskData.target to avoid memory leak\n                // issue, https://github.com/angular/angular/issues/20442\n                taskData.target = null;\n                // need to clear up taskData because it is a global object\n                if (data) {\n                    data.taskData = null;\n                }\n                // have to save those information to task in case\n                // application may call task.zone.cancelTask() directly\n                if (once) {\n                    options.once = true;\n                }\n                if (!(!passiveSupported && typeof task.options === 'boolean')) {\n                    // if not support passive, and we pass an option object\n                    // to addEventListener, we should save the options to task\n                    task.options = options;\n                }\n                task.target = target;\n                task.capture = capture;\n                task.eventName = eventName;\n                if (isHandleEvent) {\n                    // save original delegate for compare to check duplicate\n                    task.originalDelegate = delegate;\n                }\n                if (!prepend) {\n                    existingTasks.push(task);\n                }\n                else {\n                    existingTasks.unshift(task);\n                }\n                if (returnTarget) {\n                    return target;\n                }\n            };\n        };\n        proto[ADD_EVENT_LISTENER] = makeAddListener(nativeAddEventListener, ADD_EVENT_LISTENER_SOURCE, customSchedule, customCancel, returnTarget);\n        if (nativePrependEventListener) {\n            proto[PREPEND_EVENT_LISTENER] = makeAddListener(nativePrependEventListener, PREPEND_EVENT_LISTENER_SOURCE, customSchedulePrepend, customCancel, returnTarget, true);\n        }\n        proto[REMOVE_EVENT_LISTENER] = function () {\n            const target = this || _global;\n            let eventName = arguments[0];\n            if (patchOptions && patchOptions.transferEventName) {\n                eventName = patchOptions.transferEventName(eventName);\n            }\n            const options = arguments[2];\n            const capture = !options ? false : typeof options === 'boolean' ? true : options.capture;\n            const delegate = arguments[1];\n            if (!delegate) {\n                return nativeRemoveEventListener.apply(this, arguments);\n            }\n            if (validateHandler &&\n                !validateHandler(nativeRemoveEventListener, delegate, target, arguments)) {\n                return;\n            }\n            const symbolEventNames = zoneSymbolEventNames$1[eventName];\n            let symbolEventName;\n            if (symbolEventNames) {\n                symbolEventName = symbolEventNames[capture ? TRUE_STR : FALSE_STR];\n            }\n            const existingTasks = symbolEventName && target[symbolEventName];\n            if (existingTasks) {\n                for (let i = 0; i < existingTasks.length; i++) {\n                    const existingTask = existingTasks[i];\n                    if (compare(existingTask, delegate)) {\n                        existingTasks.splice(i, 1);\n                        // set isRemoved to data for faster invokeTask check\n                        existingTask.isRemoved = true;\n                        if (existingTasks.length === 0) {\n                            // all tasks for the eventName + capture have gone,\n                            // remove globalZoneAwareCallback and remove the task cache from target\n                            existingTask.allRemoved = true;\n                            target[symbolEventName] = null;\n                            // in the target, we have an event listener which is added by on_property\n                            // such as target.onclick = function() {}, so we need to clear this internal\n                            // property too if all delegates all removed\n                            if (typeof eventName === 'string') {\n                                const onPropertySymbol = ZONE_SYMBOL_PREFIX + 'ON_PROPERTY' + eventName;\n                                target[onPropertySymbol] = null;\n                            }\n                        }\n                        existingTask.zone.cancelTask(existingTask);\n                        if (returnTarget) {\n                            return target;\n                        }\n                        return;\n                    }\n                }\n            }\n            // issue 930, didn't find the event name or callback\n            // from zone kept existingTasks, the callback maybe\n            // added outside of zone, we need to call native removeEventListener\n            // to try to remove it.\n            return nativeRemoveEventListener.apply(this, arguments);\n        };\n        proto[LISTENERS_EVENT_LISTENER] = function () {\n            const target = this || _global;\n            let eventName = arguments[0];\n            if (patchOptions && patchOptions.transferEventName) {\n                eventName = patchOptions.transferEventName(eventName);\n            }\n            const listeners = [];\n            const tasks = findEventTasks(target, eventNameToString ? eventNameToString(eventName) : eventName);\n            for (let i = 0; i < tasks.length; i++) {\n                const task = tasks[i];\n                let delegate = task.originalDelegate ? task.originalDelegate : task.callback;\n                listeners.push(delegate);\n            }\n            return listeners;\n        };\n        proto[REMOVE_ALL_LISTENERS_EVENT_LISTENER] = function () {\n            const target = this || _global;\n            let eventName = arguments[0];\n            if (!eventName) {\n                const keys = Object.keys(target);\n                for (let i = 0; i < keys.length; i++) {\n                    const prop = keys[i];\n                    const match = EVENT_NAME_SYMBOL_REGX.exec(prop);\n                    let evtName = match && match[1];\n                    // in nodejs EventEmitter, removeListener event is\n                    // used for monitoring the removeListener call,\n                    // so just keep removeListener eventListener until\n                    // all other eventListeners are removed\n                    if (evtName && evtName !== 'removeListener') {\n                        this[REMOVE_ALL_LISTENERS_EVENT_LISTENER].call(this, evtName);\n                    }\n                }\n                // remove removeListener listener finally\n                this[REMOVE_ALL_LISTENERS_EVENT_LISTENER].call(this, 'removeListener');\n            }\n            else {\n                if (patchOptions && patchOptions.transferEventName) {\n                    eventName = patchOptions.transferEventName(eventName);\n                }\n                const symbolEventNames = zoneSymbolEventNames$1[eventName];\n                if (symbolEventNames) {\n                    const symbolEventName = symbolEventNames[FALSE_STR];\n                    const symbolCaptureEventName = symbolEventNames[TRUE_STR];\n                    const tasks = target[symbolEventName];\n                    const captureTasks = target[symbolCaptureEventName];\n                    if (tasks) {\n                        const removeTasks = tasks.slice();\n                        for (let i = 0; i < removeTasks.length; i++) {\n                            const task = removeTasks[i];\n                            let delegate = task.originalDelegate ? task.originalDelegate : task.callback;\n                            this[REMOVE_EVENT_LISTENER].call(this, eventName, delegate, task.options);\n                        }\n                    }\n                    if (captureTasks) {\n                        const removeTasks = captureTasks.slice();\n                        for (let i = 0; i < removeTasks.length; i++) {\n                            const task = removeTasks[i];\n                            let delegate = task.originalDelegate ? task.originalDelegate : task.callback;\n                            this[REMOVE_EVENT_LISTENER].call(this, eventName, delegate, task.options);\n                        }\n                    }\n                }\n            }\n            if (returnTarget) {\n                return this;\n            }\n        };\n        // for native toString patch\n        attachOriginToPatched(proto[ADD_EVENT_LISTENER], nativeAddEventListener);\n        attachOriginToPatched(proto[REMOVE_EVENT_LISTENER], nativeRemoveEventListener);\n        if (nativeRemoveAllListeners) {\n            attachOriginToPatched(proto[REMOVE_ALL_LISTENERS_EVENT_LISTENER], nativeRemoveAllListeners);\n        }\n        if (nativeListeners) {\n            attachOriginToPatched(proto[LISTENERS_EVENT_LISTENER], nativeListeners);\n        }\n        return true;\n    }\n    let results = [];\n    for (let i = 0; i < apis.length; i++) {\n        results[i] = patchEventTargetMethods(apis[i], patchOptions);\n    }\n    return results;\n}\nfunction findEventTasks(target, eventName) {\n    if (!eventName) {\n        const foundTasks = [];\n        for (let prop in target) {\n            const match = EVENT_NAME_SYMBOL_REGX.exec(prop);\n            let evtName = match && match[1];\n            if (evtName && (!eventName || evtName === eventName)) {\n                const tasks = target[prop];\n                if (tasks) {\n                    for (let i = 0; i < tasks.length; i++) {\n                        foundTasks.push(tasks[i]);\n                    }\n                }\n            }\n        }\n        return foundTasks;\n    }\n    let symbolEventName = zoneSymbolEventNames$1[eventName];\n    if (!symbolEventName) {\n        prepareEventNames(eventName);\n        symbolEventName = zoneSymbolEventNames$1[eventName];\n    }\n    const captureFalseTasks = target[symbolEventName[FALSE_STR]];\n    const captureTrueTasks = target[symbolEventName[TRUE_STR]];\n    if (!captureFalseTasks) {\n        return captureTrueTasks ? captureTrueTasks.slice() : [];\n    }\n    else {\n        return captureTrueTasks ? captureFalseTasks.concat(captureTrueTasks) :\n            captureFalseTasks.slice();\n    }\n}\nfunction patchEventPrototype(global, api) {\n    const Event = global['Event'];\n    if (Event && Event.prototype) {\n        api.patchMethod(Event.prototype, 'stopImmediatePropagation', (delegate) => function (self, args) {\n            self[IMMEDIATE_PROPAGATION_SYMBOL] = true;\n            // we need to call the native stopImmediatePropagation\n            // in case in some hybrid application, some part of\n            // application will be controlled by zone, some are not\n            delegate && delegate.apply(self, args);\n        });\n    }\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nfunction patchCallbacks(api, target, targetName, method, callbacks) {\n    const symbol = Zone.__symbol__(method);\n    if (target[symbol]) {\n        return;\n    }\n    const nativeDelegate = target[symbol] = target[method];\n    target[method] = function (name, opts, options) {\n        if (opts && opts.prototype) {\n            callbacks.forEach(function (callback) {\n                const source = `${targetName}.${method}::` + callback;\n                const prototype = opts.prototype;\n                if (prototype.hasOwnProperty(callback)) {\n                    const descriptor = api.ObjectGetOwnPropertyDescriptor(prototype, callback);\n                    if (descriptor && descriptor.value) {\n                        descriptor.value = api.wrapWithCurrentZone(descriptor.value, source);\n                        api._redefineProperty(opts.prototype, callback, descriptor);\n                    }\n                    else if (prototype[callback]) {\n                        prototype[callback] = api.wrapWithCurrentZone(prototype[callback], source);\n                    }\n                }\n                else if (prototype[callback]) {\n                    prototype[callback] = api.wrapWithCurrentZone(prototype[callback], source);\n                }\n            });\n        }\n        return nativeDelegate.call(target, name, opts, options);\n    };\n    api.attachOriginToPatched(target[method], nativeDelegate);\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nconst globalEventHandlersEventNames = [\n    'abort',\n    'animationcancel',\n    'animationend',\n    'animationiteration',\n    'auxclick',\n    'beforeinput',\n    'blur',\n    'cancel',\n    'canplay',\n    'canplaythrough',\n    'change',\n    'compositionstart',\n    'compositionupdate',\n    'compositionend',\n    'cuechange',\n    'click',\n    'close',\n    'contextmenu',\n    'curechange',\n    'dblclick',\n    'drag',\n    'dragend',\n    'dragenter',\n    'dragexit',\n    'dragleave',\n    'dragover',\n    'drop',\n    'durationchange',\n    'emptied',\n    'ended',\n    'error',\n    'focus',\n    'focusin',\n    'focusout',\n    'gotpointercapture',\n    'input',\n    'invalid',\n    'keydown',\n    'keypress',\n    'keyup',\n    'load',\n    'loadstart',\n    'loadeddata',\n    'loadedmetadata',\n    'lostpointercapture',\n    'mousedown',\n    'mouseenter',\n    'mouseleave',\n    'mousemove',\n    'mouseout',\n    'mouseover',\n    'mouseup',\n    'mousewheel',\n    'orientationchange',\n    'pause',\n    'play',\n    'playing',\n    'pointercancel',\n    'pointerdown',\n    'pointerenter',\n    'pointerleave',\n    'pointerlockchange',\n    'mozpointerlockchange',\n    'webkitpointerlockerchange',\n    'pointerlockerror',\n    'mozpointerlockerror',\n    'webkitpointerlockerror',\n    'pointermove',\n    'pointout',\n    'pointerover',\n    'pointerup',\n    'progress',\n    'ratechange',\n    'reset',\n    'resize',\n    'scroll',\n    'seeked',\n    'seeking',\n    'select',\n    'selectionchange',\n    'selectstart',\n    'show',\n    'sort',\n    'stalled',\n    'submit',\n    'suspend',\n    'timeupdate',\n    'volumechange',\n    'touchcancel',\n    'touchmove',\n    'touchstart',\n    'touchend',\n    'transitioncancel',\n    'transitionend',\n    'waiting',\n    'wheel'\n];\nconst documentEventNames = [\n    'afterscriptexecute', 'beforescriptexecute', 'DOMContentLoaded', 'freeze', 'fullscreenchange',\n    'mozfullscreenchange', 'webkitfullscreenchange', 'msfullscreenchange', 'fullscreenerror',\n    'mozfullscreenerror', 'webkitfullscreenerror', 'msfullscreenerror', 'readystatechange',\n    'visibilitychange', 'resume'\n];\nconst windowEventNames = [\n    'absolutedeviceorientation',\n    'afterinput',\n    'afterprint',\n    'appinstalled',\n    'beforeinstallprompt',\n    'beforeprint',\n    'beforeunload',\n    'devicelight',\n    'devicemotion',\n    'deviceorientation',\n    'deviceorientationabsolute',\n    'deviceproximity',\n    'hashchange',\n    'languagechange',\n    'message',\n    'mozbeforepaint',\n    'offline',\n    'online',\n    'paint',\n    'pageshow',\n    'pagehide',\n    'popstate',\n    'rejectionhandled',\n    'storage',\n    'unhandledrejection',\n    'unload',\n    'userproximity',\n    'vrdisplayconnected',\n    'vrdisplaydisconnected',\n    'vrdisplaypresentchange'\n];\nconst htmlElementEventNames = [\n    'beforecopy', 'beforecut', 'beforepaste', 'copy', 'cut', 'paste', 'dragstart', 'loadend',\n    'animationstart', 'search', 'transitionrun', 'transitionstart', 'webkitanimationend',\n    'webkitanimationiteration', 'webkitanimationstart', 'webkittransitionend'\n];\nconst mediaElementEventNames = ['encrypted', 'waitingforkey', 'msneedkey', 'mozinterruptbegin', 'mozinterruptend'];\nconst ieElementEventNames = [\n    'activate',\n    'afterupdate',\n    'ariarequest',\n    'beforeactivate',\n    'beforedeactivate',\n    'beforeeditfocus',\n    'beforeupdate',\n    'cellchange',\n    'controlselect',\n    'dataavailable',\n    'datasetchanged',\n    'datasetcomplete',\n    'errorupdate',\n    'filterchange',\n    'layoutcomplete',\n    'losecapture',\n    'move',\n    'moveend',\n    'movestart',\n    'propertychange',\n    'resizeend',\n    'resizestart',\n    'rowenter',\n    'rowexit',\n    'rowsdelete',\n    'rowsinserted',\n    'command',\n    'compassneedscalibration',\n    'deactivate',\n    'help',\n    'mscontentzoom',\n    'msmanipulationstatechanged',\n    'msgesturechange',\n    'msgesturedoubletap',\n    'msgestureend',\n    'msgesturehold',\n    'msgesturestart',\n    'msgesturetap',\n    'msgotpointercapture',\n    'msinertiastart',\n    'mslostpointercapture',\n    'mspointercancel',\n    'mspointerdown',\n    'mspointerenter',\n    'mspointerhover',\n    'mspointerleave',\n    'mspointermove',\n    'mspointerout',\n    'mspointerover',\n    'mspointerup',\n    'pointerout',\n    'mssitemodejumplistitemremoved',\n    'msthumbnailclick',\n    'stop',\n    'storagecommit'\n];\nconst webglEventNames = ['webglcontextrestored', 'webglcontextlost', 'webglcontextcreationerror'];\nconst formEventNames = ['autocomplete', 'autocompleteerror'];\nconst detailEventNames = ['toggle'];\nconst frameEventNames = ['load'];\nconst frameSetEventNames = ['blur', 'error', 'focus', 'load', 'resize', 'scroll', 'messageerror'];\nconst marqueeEventNames = ['bounce', 'finish', 'start'];\nconst XMLHttpRequestEventNames = [\n    'loadstart', 'progress', 'abort', 'error', 'load', 'progress', 'timeout', 'loadend',\n    'readystatechange'\n];\nconst IDBIndexEventNames = ['upgradeneeded', 'complete', 'abort', 'success', 'error', 'blocked', 'versionchange', 'close'];\nconst websocketEventNames = ['close', 'error', 'open', 'message'];\nconst workerEventNames = ['error', 'message'];\nconst eventNames = globalEventHandlersEventNames.concat(webglEventNames, formEventNames, detailEventNames, documentEventNames, windowEventNames, htmlElementEventNames, ieElementEventNames);\nfunction filterProperties(target, onProperties, ignoreProperties) {\n    if (!ignoreProperties || ignoreProperties.length === 0) {\n        return onProperties;\n    }\n    const tip = ignoreProperties.filter(ip => ip.target === target);\n    if (!tip || tip.length === 0) {\n        return onProperties;\n    }\n    const targetIgnoreProperties = tip[0].ignoreProperties;\n    return onProperties.filter(op => targetIgnoreProperties.indexOf(op) === -1);\n}\nfunction patchFilteredProperties(target, onProperties, ignoreProperties, prototype) {\n    // check whether target is available, sometimes target will be undefined\n    // because different browser or some 3rd party plugin.\n    if (!target) {\n        return;\n    }\n    const filteredProperties = filterProperties(target, onProperties, ignoreProperties);\n    patchOnProperties(target, filteredProperties, prototype);\n}\nfunction propertyDescriptorPatch(api, _global) {\n    if (isNode && !isMix) {\n        return;\n    }\n    if (Zone[api.symbol('patchEvents')]) {\n        // events are already been patched by legacy patch.\n        return;\n    }\n    const supportsWebSocket = typeof WebSocket !== 'undefined';\n    const ignoreProperties = _global['__Zone_ignore_on_properties'];\n    // for browsers that we can patch the descriptor:  Chrome & Firefox\n    if (isBrowser) {\n        const internalWindow = window;\n        const ignoreErrorProperties = isIE() ? [{ target: internalWindow, ignoreProperties: ['error'] }] : [];\n        // in IE/Edge, onProp not exist in window object, but in WindowPrototype\n        // so we need to pass WindowPrototype to check onProp exist or not\n        patchFilteredProperties(internalWindow, eventNames.concat(['messageerror']), ignoreProperties ? ignoreProperties.concat(ignoreErrorProperties) : ignoreProperties, ObjectGetPrototypeOf(internalWindow));\n        patchFilteredProperties(Document.prototype, eventNames, ignoreProperties);\n        if (typeof internalWindow['SVGElement'] !== 'undefined') {\n            patchFilteredProperties(internalWindow['SVGElement'].prototype, eventNames, ignoreProperties);\n        }\n        patchFilteredProperties(Element.prototype, eventNames, ignoreProperties);\n        patchFilteredProperties(HTMLElement.prototype, eventNames, ignoreProperties);\n        patchFilteredProperties(HTMLMediaElement.prototype, mediaElementEventNames, ignoreProperties);\n        patchFilteredProperties(HTMLFrameSetElement.prototype, windowEventNames.concat(frameSetEventNames), ignoreProperties);\n        patchFilteredProperties(HTMLBodyElement.prototype, windowEventNames.concat(frameSetEventNames), ignoreProperties);\n        patchFilteredProperties(HTMLFrameElement.prototype, frameEventNames, ignoreProperties);\n        patchFilteredProperties(HTMLIFrameElement.prototype, frameEventNames, ignoreProperties);\n        const HTMLMarqueeElement = internalWindow['HTMLMarqueeElement'];\n        if (HTMLMarqueeElement) {\n            patchFilteredProperties(HTMLMarqueeElement.prototype, marqueeEventNames, ignoreProperties);\n        }\n        const Worker = internalWindow['Worker'];\n        if (Worker) {\n            patchFilteredProperties(Worker.prototype, workerEventNames, ignoreProperties);\n        }\n    }\n    const XMLHttpRequest = _global['XMLHttpRequest'];\n    if (XMLHttpRequest) {\n        // XMLHttpRequest is not available in ServiceWorker, so we need to check here\n        patchFilteredProperties(XMLHttpRequest.prototype, XMLHttpRequestEventNames, ignoreProperties);\n    }\n    const XMLHttpRequestEventTarget = _global['XMLHttpRequestEventTarget'];\n    if (XMLHttpRequestEventTarget) {\n        patchFilteredProperties(XMLHttpRequestEventTarget && XMLHttpRequestEventTarget.prototype, XMLHttpRequestEventNames, ignoreProperties);\n    }\n    if (typeof IDBIndex !== 'undefined') {\n        patchFilteredProperties(IDBIndex.prototype, IDBIndexEventNames, ignoreProperties);\n        patchFilteredProperties(IDBRequest.prototype, IDBIndexEventNames, ignoreProperties);\n        patchFilteredProperties(IDBOpenDBRequest.prototype, IDBIndexEventNames, ignoreProperties);\n        patchFilteredProperties(IDBDatabase.prototype, IDBIndexEventNames, ignoreProperties);\n        patchFilteredProperties(IDBTransaction.prototype, IDBIndexEventNames, ignoreProperties);\n        patchFilteredProperties(IDBCursor.prototype, IDBIndexEventNames, ignoreProperties);\n    }\n    if (supportsWebSocket) {\n        patchFilteredProperties(WebSocket.prototype, websocketEventNames, ignoreProperties);\n    }\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nZone.__load_patch('util', (global, Zone, api) => {\n    api.patchOnProperties = patchOnProperties;\n    api.patchMethod = patchMethod;\n    api.bindArguments = bindArguments;\n    api.patchMacroTask = patchMacroTask;\n    // In earlier version of zone.js (<0.9.0), we use env name `__zone_symbol__BLACK_LISTED_EVENTS` to\n    // define which events will not be patched by `Zone.js`.\n    // In newer version (>=0.9.0), we change the env name to `__zone_symbol__UNPATCHED_EVENTS` to keep\n    // the name consistent with angular repo.\n    // The  `__zone_symbol__BLACK_LISTED_EVENTS` is deprecated, but it is still be supported for\n    // backwards compatibility.\n    const SYMBOL_BLACK_LISTED_EVENTS = Zone.__symbol__('BLACK_LISTED_EVENTS');\n    const SYMBOL_UNPATCHED_EVENTS = Zone.__symbol__('UNPATCHED_EVENTS');\n    if (global[SYMBOL_UNPATCHED_EVENTS]) {\n        global[SYMBOL_BLACK_LISTED_EVENTS] = global[SYMBOL_UNPATCHED_EVENTS];\n    }\n    if (global[SYMBOL_BLACK_LISTED_EVENTS]) {\n        Zone[SYMBOL_BLACK_LISTED_EVENTS] = Zone[SYMBOL_UNPATCHED_EVENTS] =\n            global[SYMBOL_BLACK_LISTED_EVENTS];\n    }\n    api.patchEventPrototype = patchEventPrototype;\n    api.patchEventTarget = patchEventTarget;\n    api.isIEOrEdge = isIEOrEdge;\n    api.ObjectDefineProperty = ObjectDefineProperty;\n    api.ObjectGetOwnPropertyDescriptor = ObjectGetOwnPropertyDescriptor;\n    api.ObjectCreate = ObjectCreate;\n    api.ArraySlice = ArraySlice;\n    api.patchClass = patchClass;\n    api.wrapWithCurrentZone = wrapWithCurrentZone;\n    api.filterProperties = filterProperties;\n    api.attachOriginToPatched = attachOriginToPatched;\n    api._redefineProperty = Object.defineProperty;\n    api.patchCallbacks = patchCallbacks;\n    api.getGlobalObjects = () => ({\n        globalSources,\n        zoneSymbolEventNames: zoneSymbolEventNames$1,\n        eventNames,\n        isBrowser,\n        isMix,\n        isNode,\n        TRUE_STR,\n        FALSE_STR,\n        ZONE_SYMBOL_PREFIX,\n        ADD_EVENT_LISTENER_STR,\n        REMOVE_EVENT_LISTENER_STR\n    });\n});\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nconst taskSymbol = zoneSymbol('zoneTask');\nfunction patchTimer(window, setName, cancelName, nameSuffix) {\n    let setNative = null;\n    let clearNative = null;\n    setName += nameSuffix;\n    cancelName += nameSuffix;\n    const tasksByHandleId = {};\n    function scheduleTask(task) {\n        const data = task.data;\n        function timer() {\n            try {\n                task.invoke.apply(this, arguments);\n            }\n            finally {\n                // issue-934, task will be cancelled\n                // even it is a periodic task such as\n                // setInterval\n                if (!(task.data && task.data.isPeriodic)) {\n                    if (typeof data.handleId === 'number') {\n                        // in non-nodejs env, we remove timerId\n                        // from local cache\n                        delete tasksByHandleId[data.handleId];\n                    }\n                    else if (data.handleId) {\n                        // Node returns complex objects as handleIds\n                        // we remove task reference from timer object\n                        data.handleId[taskSymbol] = null;\n                    }\n                }\n            }\n        }\n        data.args[0] = timer;\n        data.handleId = setNative.apply(window, data.args);\n        return task;\n    }\n    function clearTask(task) {\n        return clearNative.call(window, task.data.handleId);\n    }\n    setNative =\n        patchMethod(window, setName, (delegate) => function (self, args) {\n            if (typeof args[0] === 'function') {\n                const options = {\n                    isPeriodic: nameSuffix === 'Interval',\n                    delay: (nameSuffix === 'Timeout' || nameSuffix === 'Interval') ? args[1] || 0 :\n                        undefined,\n                    args: args\n                };\n                const task = scheduleMacroTaskWithCurrentZone(setName, args[0], options, scheduleTask, clearTask);\n                if (!task) {\n                    return task;\n                }\n                // Node.js must additionally support the ref and unref functions.\n                const handle = task.data.handleId;\n                if (typeof handle === 'number') {\n                    // for non nodejs env, we save handleId: task\n                    // mapping in local cache for clearTimeout\n                    tasksByHandleId[handle] = task;\n                }\n                else if (handle) {\n                    // for nodejs env, we save task\n                    // reference in timerId Object for clearTimeout\n                    handle[taskSymbol] = task;\n                }\n                // check whether handle is null, because some polyfill or browser\n                // may return undefined from setTimeout/setInterval/setImmediate/requestAnimationFrame\n                if (handle && handle.ref && handle.unref && typeof handle.ref === 'function' &&\n                    typeof handle.unref === 'function') {\n                    task.ref = handle.ref.bind(handle);\n                    task.unref = handle.unref.bind(handle);\n                }\n                if (typeof handle === 'number' || handle) {\n                    return handle;\n                }\n                return task;\n            }\n            else {\n                // cause an error by calling it directly.\n                return delegate.apply(window, args);\n            }\n        });\n    clearNative =\n        patchMethod(window, cancelName, (delegate) => function (self, args) {\n            const id = args[0];\n            let task;\n            if (typeof id === 'number') {\n                // non nodejs env.\n                task = tasksByHandleId[id];\n            }\n            else {\n                // nodejs env.\n                task = id && id[taskSymbol];\n                // other environments.\n                if (!task) {\n                    task = id;\n                }\n            }\n            if (task && typeof task.type === 'string') {\n                if (task.state !== 'notScheduled' &&\n                    (task.cancelFn && task.data.isPeriodic || task.runCount === 0)) {\n                    if (typeof id === 'number') {\n                        delete tasksByHandleId[id];\n                    }\n                    else if (id) {\n                        id[taskSymbol] = null;\n                    }\n                    // Do not cancel already canceled functions\n                    task.zone.cancelTask(task);\n                }\n            }\n            else {\n                // cause an error by calling it directly.\n                delegate.apply(window, args);\n            }\n        });\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nfunction patchCustomElements(_global, api) {\n    const { isBrowser, isMix } = api.getGlobalObjects();\n    if ((!isBrowser && !isMix) || !_global['customElements'] || !('customElements' in _global)) {\n        return;\n    }\n    const callbacks = ['connectedCallback', 'disconnectedCallback', 'adoptedCallback', 'attributeChangedCallback'];\n    api.patchCallbacks(api, _global.customElements, 'customElements', 'define', callbacks);\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nfunction eventTargetPatch(_global, api) {\n    if (Zone[api.symbol('patchEventTarget')]) {\n        // EventTarget is already patched.\n        return;\n    }\n    const { eventNames, zoneSymbolEventNames, TRUE_STR, FALSE_STR, ZONE_SYMBOL_PREFIX } = api.getGlobalObjects();\n    //  predefine all __zone_symbol__ + eventName + true/false string\n    for (let i = 0; i < eventNames.length; i++) {\n        const eventName = eventNames[i];\n        const falseEventName = eventName + FALSE_STR;\n        const trueEventName = eventName + TRUE_STR;\n        const symbol = ZONE_SYMBOL_PREFIX + falseEventName;\n        const symbolCapture = ZONE_SYMBOL_PREFIX + trueEventName;\n        zoneSymbolEventNames[eventName] = {};\n        zoneSymbolEventNames[eventName][FALSE_STR] = symbol;\n        zoneSymbolEventNames[eventName][TRUE_STR] = symbolCapture;\n    }\n    const EVENT_TARGET = _global['EventTarget'];\n    if (!EVENT_TARGET || !EVENT_TARGET.prototype) {\n        return;\n    }\n    api.patchEventTarget(_global, [EVENT_TARGET && EVENT_TARGET.prototype]);\n    return true;\n}\nfunction patchEvent(global, api) {\n    api.patchEventPrototype(global, api);\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nZone.__load_patch('legacy', (global) => {\n    const legacyPatch = global[Zone.__symbol__('legacyPatch')];\n    if (legacyPatch) {\n        legacyPatch();\n    }\n});\nZone.__load_patch('timers', (global) => {\n    const set = 'set';\n    const clear = 'clear';\n    patchTimer(global, set, clear, 'Timeout');\n    patchTimer(global, set, clear, 'Interval');\n    patchTimer(global, set, clear, 'Immediate');\n});\nZone.__load_patch('requestAnimationFrame', (global) => {\n    patchTimer(global, 'request', 'cancel', 'AnimationFrame');\n    patchTimer(global, 'mozRequest', 'mozCancel', 'AnimationFrame');\n    patchTimer(global, 'webkitRequest', 'webkitCancel', 'AnimationFrame');\n});\nZone.__load_patch('blocking', (global, Zone) => {\n    const blockingMethods = ['alert', 'prompt', 'confirm'];\n    for (let i = 0; i < blockingMethods.length; i++) {\n        const name = blockingMethods[i];\n        patchMethod(global, name, (delegate, symbol, name) => {\n            return function (s, args) {\n                return Zone.current.run(delegate, global, args, name);\n            };\n        });\n    }\n});\nZone.__load_patch('EventTarget', (global, Zone, api) => {\n    patchEvent(global, api);\n    eventTargetPatch(global, api);\n    // patch XMLHttpRequestEventTarget's addEventListener/removeEventListener\n    const XMLHttpRequestEventTarget = global['XMLHttpRequestEventTarget'];\n    if (XMLHttpRequestEventTarget && XMLHttpRequestEventTarget.prototype) {\n        api.patchEventTarget(global, [XMLHttpRequestEventTarget.prototype]);\n    }\n});\nZone.__load_patch('MutationObserver', (global, Zone, api) => {\n    patchClass('MutationObserver');\n    patchClass('WebKitMutationObserver');\n});\nZone.__load_patch('IntersectionObserver', (global, Zone, api) => {\n    patchClass('IntersectionObserver');\n});\nZone.__load_patch('FileReader', (global, Zone, api) => {\n    patchClass('FileReader');\n});\nZone.__load_patch('on_property', (global, Zone, api) => {\n    propertyDescriptorPatch(api, global);\n});\nZone.__load_patch('customElements', (global, Zone, api) => {\n    patchCustomElements(global, api);\n});\nZone.__load_patch('XHR', (global, Zone) => {\n    // Treat XMLHttpRequest as a macrotask.\n    patchXHR(global);\n    const XHR_TASK = zoneSymbol('xhrTask');\n    const XHR_SYNC = zoneSymbol('xhrSync');\n    const XHR_LISTENER = zoneSymbol('xhrListener');\n    const XHR_SCHEDULED = zoneSymbol('xhrScheduled');\n    const XHR_URL = zoneSymbol('xhrURL');\n    const XHR_ERROR_BEFORE_SCHEDULED = zoneSymbol('xhrErrorBeforeScheduled');\n    function patchXHR(window) {\n        const XMLHttpRequest = window['XMLHttpRequest'];\n        if (!XMLHttpRequest) {\n            // XMLHttpRequest is not available in service worker\n            return;\n        }\n        const XMLHttpRequestPrototype = XMLHttpRequest.prototype;\n        function findPendingTask(target) {\n            return target[XHR_TASK];\n        }\n        let oriAddListener = XMLHttpRequestPrototype[ZONE_SYMBOL_ADD_EVENT_LISTENER];\n        let oriRemoveListener = XMLHttpRequestPrototype[ZONE_SYMBOL_REMOVE_EVENT_LISTENER];\n        if (!oriAddListener) {\n            const XMLHttpRequestEventTarget = window['XMLHttpRequestEventTarget'];\n            if (XMLHttpRequestEventTarget) {\n                const XMLHttpRequestEventTargetPrototype = XMLHttpRequestEventTarget.prototype;\n                oriAddListener = XMLHttpRequestEventTargetPrototype[ZONE_SYMBOL_ADD_EVENT_LISTENER];\n                oriRemoveListener = XMLHttpRequestEventTargetPrototype[ZONE_SYMBOL_REMOVE_EVENT_LISTENER];\n            }\n        }\n        const READY_STATE_CHANGE = 'readystatechange';\n        const SCHEDULED = 'scheduled';\n        function scheduleTask(task) {\n            const data = task.data;\n            const target = data.target;\n            target[XHR_SCHEDULED] = false;\n            target[XHR_ERROR_BEFORE_SCHEDULED] = false;\n            // remove existing event listener\n            const listener = target[XHR_LISTENER];\n            if (!oriAddListener) {\n                oriAddListener = target[ZONE_SYMBOL_ADD_EVENT_LISTENER];\n                oriRemoveListener = target[ZONE_SYMBOL_REMOVE_EVENT_LISTENER];\n            }\n            if (listener) {\n                oriRemoveListener.call(target, READY_STATE_CHANGE, listener);\n            }\n            const newListener = target[XHR_LISTENER] = () => {\n                if (target.readyState === target.DONE) {\n                    // sometimes on some browsers XMLHttpRequest will fire onreadystatechange with\n                    // readyState=4 multiple times, so we need to check task state here\n                    if (!data.aborted && target[XHR_SCHEDULED] && task.state === SCHEDULED) {\n                        // check whether the xhr has registered onload listener\n                        // if that is the case, the task should invoke after all\n                        // onload listeners finish.\n                        // Also if the request failed without response (status = 0), the load event handler\n                        // will not be triggered, in that case, we should also invoke the placeholder callback\n                        // to close the XMLHttpRequest::send macroTask.\n                        // https://github.com/angular/angular/issues/38795\n                        const loadTasks = target[Zone.__symbol__('loadfalse')];\n                        if (target.status !== 0 && loadTasks && loadTasks.length > 0) {\n                            const oriInvoke = task.invoke;\n                            task.invoke = function () {\n                                // need to load the tasks again, because in other\n                                // load listener, they may remove themselves\n                                const loadTasks = target[Zone.__symbol__('loadfalse')];\n                                for (let i = 0; i < loadTasks.length; i++) {\n                                    if (loadTasks[i] === task) {\n                                        loadTasks.splice(i, 1);\n                                    }\n                                }\n                                if (!data.aborted && task.state === SCHEDULED) {\n                                    oriInvoke.call(task);\n                                }\n                            };\n                            loadTasks.push(task);\n                        }\n                        else {\n                            task.invoke();\n                        }\n                    }\n                    else if (!data.aborted && target[XHR_SCHEDULED] === false) {\n                        // error occurs when xhr.send()\n                        target[XHR_ERROR_BEFORE_SCHEDULED] = true;\n                    }\n                }\n            };\n            oriAddListener.call(target, READY_STATE_CHANGE, newListener);\n            const storedTask = target[XHR_TASK];\n            if (!storedTask) {\n                target[XHR_TASK] = task;\n            }\n            sendNative.apply(target, data.args);\n            target[XHR_SCHEDULED] = true;\n            return task;\n        }\n        function placeholderCallback() { }\n        function clearTask(task) {\n            const data = task.data;\n            // Note - ideally, we would call data.target.removeEventListener here, but it's too late\n            // to prevent it from firing. So instead, we store info for the event listener.\n            data.aborted = true;\n            return abortNative.apply(data.target, data.args);\n        }\n        const openNative = patchMethod(XMLHttpRequestPrototype, 'open', () => function (self, args) {\n            self[XHR_SYNC] = args[2] == false;\n            self[XHR_URL] = args[1];\n            return openNative.apply(self, args);\n        });\n        const XMLHTTPREQUEST_SOURCE = 'XMLHttpRequest.send';\n        const fetchTaskAborting = zoneSymbol('fetchTaskAborting');\n        const fetchTaskScheduling = zoneSymbol('fetchTaskScheduling');\n        const sendNative = patchMethod(XMLHttpRequestPrototype, 'send', () => function (self, args) {\n            if (Zone.current[fetchTaskScheduling] === true) {\n                // a fetch is scheduling, so we are using xhr to polyfill fetch\n                // and because we already schedule macroTask for fetch, we should\n                // not schedule a macroTask for xhr again\n                return sendNative.apply(self, args);\n            }\n            if (self[XHR_SYNC]) {\n                // if the XHR is sync there is no task to schedule, just execute the code.\n                return sendNative.apply(self, args);\n            }\n            else {\n                const options = { target: self, url: self[XHR_URL], isPeriodic: false, args: args, aborted: false };\n                const task = scheduleMacroTaskWithCurrentZone(XMLHTTPREQUEST_SOURCE, placeholderCallback, options, scheduleTask, clearTask);\n                if (self && self[XHR_ERROR_BEFORE_SCHEDULED] === true && !options.aborted &&\n                    task.state === SCHEDULED) {\n                    // xhr request throw error when send\n                    // we should invoke task instead of leaving a scheduled\n                    // pending macroTask\n                    task.invoke();\n                }\n            }\n        });\n        const abortNative = patchMethod(XMLHttpRequestPrototype, 'abort', () => function (self, args) {\n            const task = findPendingTask(self);\n            if (task && typeof task.type == 'string') {\n                // If the XHR has already completed, do nothing.\n                // If the XHR has already been aborted, do nothing.\n                // Fix #569, call abort multiple times before done will cause\n                // macroTask task count be negative number\n                if (task.cancelFn == null || (task.data && task.data.aborted)) {\n                    return;\n                }\n                task.zone.cancelTask(task);\n            }\n            else if (Zone.current[fetchTaskAborting] === true) {\n                // the abort is called from fetch polyfill, we need to call native abort of XHR.\n                return abortNative.apply(self, args);\n            }\n            // Otherwise, we are trying to abort an XHR which has not yet been sent, so there is no\n            // task\n            // to cancel. Do nothing.\n        });\n    }\n});\nZone.__load_patch('geolocation', (global) => {\n    /// GEO_LOCATION\n    if (global['navigator'] && global['navigator'].geolocation) {\n        patchPrototype(global['navigator'].geolocation, ['getCurrentPosition', 'watchPosition']);\n    }\n});\nZone.__load_patch('PromiseRejectionEvent', (global, Zone) => {\n    // handle unhandled promise rejection\n    function findPromiseRejectionHandler(evtName) {\n        return function (e) {\n            const eventTasks = findEventTasks(global, evtName);\n            eventTasks.forEach(eventTask => {\n                // windows has added unhandledrejection event listener\n                // trigger the event listener\n                const PromiseRejectionEvent = global['PromiseRejectionEvent'];\n                if (PromiseRejectionEvent) {\n                    const evt = new PromiseRejectionEvent(evtName, { promise: e.promise, reason: e.rejection });\n                    eventTask.invoke(evt);\n                }\n            });\n        };\n    }\n    if (global['PromiseRejectionEvent']) {\n        Zone[zoneSymbol('unhandledPromiseRejectionHandler')] =\n            findPromiseRejectionHandler('unhandledrejection');\n        Zone[zoneSymbol('rejectionHandledHandler')] =\n            findPromiseRejectionHandler('rejectionhandled');\n    }\n});\n\n\n//# sourceURL=webpack:///./node_modules/zone.js/fesm2015/zone.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		if(__webpack_module_cache__[moduleId]) {
/******/ 			return __webpack_module_cache__[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => module['default'] :
/******/ 				() => module;
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop)
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	// startup
/******/ 	// Load entry module
/******/ 	__webpack_require__("./experiments/microTask/js/main.js");
/******/ 	// This entry module used 'exports' so it can't be inlined
/******/ })()
;